/*
Slurm REST API

API to access and control Slurm

API version: Slurm-24.11.5&openapi/slurmctld&openapi/slurmdbd
Contact: sales@schedmd.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package slurmrestapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type SlurmdbAPI interface {

	/*
	SlurmdbV0040DeleteAccount Delete account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountName Account name
	@return SlurmdbAPISlurmdbV0040DeleteAccountRequest
	*/
	SlurmdbV0040DeleteAccount(ctx context.Context, accountName string) SlurmdbAPISlurmdbV0040DeleteAccountRequest

	// SlurmdbV0040DeleteAccountExecute executes the request
	//  @return V0040OpenapiAccountsRemovedResp
	SlurmdbV0040DeleteAccountExecute(r SlurmdbAPISlurmdbV0040DeleteAccountRequest) (*V0040OpenapiAccountsRemovedResp, *http.Response, error)

	/*
	SlurmdbV0040DeleteAssociation Delete association

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040DeleteAssociationRequest
	*/
	SlurmdbV0040DeleteAssociation(ctx context.Context) SlurmdbAPISlurmdbV0040DeleteAssociationRequest

	// SlurmdbV0040DeleteAssociationExecute executes the request
	//  @return V0040OpenapiAssocsRemovedResp
	SlurmdbV0040DeleteAssociationExecute(r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) (*V0040OpenapiAssocsRemovedResp, *http.Response, error)

	/*
	SlurmdbV0040DeleteAssociations Delete associations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040DeleteAssociationsRequest
	*/
	SlurmdbV0040DeleteAssociations(ctx context.Context) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest

	// SlurmdbV0040DeleteAssociationsExecute executes the request
	//  @return V0040OpenapiAssocsRemovedResp
	SlurmdbV0040DeleteAssociationsExecute(r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) (*V0040OpenapiAssocsRemovedResp, *http.Response, error)

	/*
	SlurmdbV0040DeleteCluster Delete cluster

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterName Cluster name
	@return SlurmdbAPISlurmdbV0040DeleteClusterRequest
	*/
	SlurmdbV0040DeleteCluster(ctx context.Context, clusterName string) SlurmdbAPISlurmdbV0040DeleteClusterRequest

	// SlurmdbV0040DeleteClusterExecute executes the request
	//  @return V0040OpenapiClustersRemovedResp
	SlurmdbV0040DeleteClusterExecute(r SlurmdbAPISlurmdbV0040DeleteClusterRequest) (*V0040OpenapiClustersRemovedResp, *http.Response, error)

	/*
	SlurmdbV0040DeleteSingleQos Delete QOS

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param qos QOS name
	@return SlurmdbAPISlurmdbV0040DeleteSingleQosRequest
	*/
	SlurmdbV0040DeleteSingleQos(ctx context.Context, qos string) SlurmdbAPISlurmdbV0040DeleteSingleQosRequest

	// SlurmdbV0040DeleteSingleQosExecute executes the request
	//  @return V0040OpenapiSlurmdbdQosRemovedResp
	SlurmdbV0040DeleteSingleQosExecute(r SlurmdbAPISlurmdbV0040DeleteSingleQosRequest) (*V0040OpenapiSlurmdbdQosRemovedResp, *http.Response, error)

	/*
	SlurmdbV0040DeleteUser Delete user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name User name
	@return SlurmdbAPISlurmdbV0040DeleteUserRequest
	*/
	SlurmdbV0040DeleteUser(ctx context.Context, name string) SlurmdbAPISlurmdbV0040DeleteUserRequest

	// SlurmdbV0040DeleteUserExecute executes the request
	//  @return V0040OpenapiResp
	SlurmdbV0040DeleteUserExecute(r SlurmdbAPISlurmdbV0040DeleteUserRequest) (*V0040OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0040DeleteWckey Delete wckey

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id wckey id
	@return SlurmdbAPISlurmdbV0040DeleteWckeyRequest
	*/
	SlurmdbV0040DeleteWckey(ctx context.Context, id string) SlurmdbAPISlurmdbV0040DeleteWckeyRequest

	// SlurmdbV0040DeleteWckeyExecute executes the request
	//  @return V0040OpenapiWckeyRemovedResp
	SlurmdbV0040DeleteWckeyExecute(r SlurmdbAPISlurmdbV0040DeleteWckeyRequest) (*V0040OpenapiWckeyRemovedResp, *http.Response, error)

	/*
	SlurmdbV0040GetAccount Get account info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountName Account name
	@return SlurmdbAPISlurmdbV0040GetAccountRequest
	*/
	SlurmdbV0040GetAccount(ctx context.Context, accountName string) SlurmdbAPISlurmdbV0040GetAccountRequest

	// SlurmdbV0040GetAccountExecute executes the request
	//  @return V0040OpenapiAccountsResp
	SlurmdbV0040GetAccountExecute(r SlurmdbAPISlurmdbV0040GetAccountRequest) (*V0040OpenapiAccountsResp, *http.Response, error)

	/*
	SlurmdbV0040GetAccounts Get account list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040GetAccountsRequest
	*/
	SlurmdbV0040GetAccounts(ctx context.Context) SlurmdbAPISlurmdbV0040GetAccountsRequest

	// SlurmdbV0040GetAccountsExecute executes the request
	//  @return V0040OpenapiAccountsResp
	SlurmdbV0040GetAccountsExecute(r SlurmdbAPISlurmdbV0040GetAccountsRequest) (*V0040OpenapiAccountsResp, *http.Response, error)

	/*
	SlurmdbV0040GetAssociation Get association info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040GetAssociationRequest
	*/
	SlurmdbV0040GetAssociation(ctx context.Context) SlurmdbAPISlurmdbV0040GetAssociationRequest

	// SlurmdbV0040GetAssociationExecute executes the request
	//  @return V0040OpenapiAssocsResp
	SlurmdbV0040GetAssociationExecute(r SlurmdbAPISlurmdbV0040GetAssociationRequest) (*V0040OpenapiAssocsResp, *http.Response, error)

	/*
	SlurmdbV0040GetAssociations Get association list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040GetAssociationsRequest
	*/
	SlurmdbV0040GetAssociations(ctx context.Context) SlurmdbAPISlurmdbV0040GetAssociationsRequest

	// SlurmdbV0040GetAssociationsExecute executes the request
	//  @return V0040OpenapiAssocsResp
	SlurmdbV0040GetAssociationsExecute(r SlurmdbAPISlurmdbV0040GetAssociationsRequest) (*V0040OpenapiAssocsResp, *http.Response, error)

	/*
	SlurmdbV0040GetCluster Get cluster info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterName Cluster name
	@return SlurmdbAPISlurmdbV0040GetClusterRequest
	*/
	SlurmdbV0040GetCluster(ctx context.Context, clusterName string) SlurmdbAPISlurmdbV0040GetClusterRequest

	// SlurmdbV0040GetClusterExecute executes the request
	//  @return V0040OpenapiClustersResp
	SlurmdbV0040GetClusterExecute(r SlurmdbAPISlurmdbV0040GetClusterRequest) (*V0040OpenapiClustersResp, *http.Response, error)

	/*
	SlurmdbV0040GetClusters Get cluster list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040GetClustersRequest
	*/
	SlurmdbV0040GetClusters(ctx context.Context) SlurmdbAPISlurmdbV0040GetClustersRequest

	// SlurmdbV0040GetClustersExecute executes the request
	//  @return V0040OpenapiClustersResp
	SlurmdbV0040GetClustersExecute(r SlurmdbAPISlurmdbV0040GetClustersRequest) (*V0040OpenapiClustersResp, *http.Response, error)

	/*
	SlurmdbV0040GetConfig Dump all configuration information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040GetConfigRequest
	*/
	SlurmdbV0040GetConfig(ctx context.Context) SlurmdbAPISlurmdbV0040GetConfigRequest

	// SlurmdbV0040GetConfigExecute executes the request
	//  @return V0040OpenapiSlurmdbdConfigResp
	SlurmdbV0040GetConfigExecute(r SlurmdbAPISlurmdbV0040GetConfigRequest) (*V0040OpenapiSlurmdbdConfigResp, *http.Response, error)

	/*
	SlurmdbV0040GetDiag Get slurmdb diagnostics

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040GetDiagRequest
	*/
	SlurmdbV0040GetDiag(ctx context.Context) SlurmdbAPISlurmdbV0040GetDiagRequest

	// SlurmdbV0040GetDiagExecute executes the request
	//  @return V0040OpenapiSlurmdbdStatsResp
	SlurmdbV0040GetDiagExecute(r SlurmdbAPISlurmdbV0040GetDiagRequest) (*V0040OpenapiSlurmdbdStatsResp, *http.Response, error)

	/*
	SlurmdbV0040GetInstance Get instance info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040GetInstanceRequest
	*/
	SlurmdbV0040GetInstance(ctx context.Context) SlurmdbAPISlurmdbV0040GetInstanceRequest

	// SlurmdbV0040GetInstanceExecute executes the request
	//  @return V0040OpenapiInstancesResp
	SlurmdbV0040GetInstanceExecute(r SlurmdbAPISlurmdbV0040GetInstanceRequest) (*V0040OpenapiInstancesResp, *http.Response, error)

	/*
	SlurmdbV0040GetInstances Get instance list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040GetInstancesRequest
	*/
	SlurmdbV0040GetInstances(ctx context.Context) SlurmdbAPISlurmdbV0040GetInstancesRequest

	// SlurmdbV0040GetInstancesExecute executes the request
	//  @return V0040OpenapiInstancesResp
	SlurmdbV0040GetInstancesExecute(r SlurmdbAPISlurmdbV0040GetInstancesRequest) (*V0040OpenapiInstancesResp, *http.Response, error)

	/*
	SlurmdbV0040GetJob Get job info

	This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId Job id
	@return SlurmdbAPISlurmdbV0040GetJobRequest
	*/
	SlurmdbV0040GetJob(ctx context.Context, jobId string) SlurmdbAPISlurmdbV0040GetJobRequest

	// SlurmdbV0040GetJobExecute executes the request
	//  @return V0040OpenapiSlurmdbdJobsResp
	SlurmdbV0040GetJobExecute(r SlurmdbAPISlurmdbV0040GetJobRequest) (*V0040OpenapiSlurmdbdJobsResp, *http.Response, error)

	/*
	SlurmdbV0040GetJobs Get job list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040GetJobsRequest
	*/
	SlurmdbV0040GetJobs(ctx context.Context) SlurmdbAPISlurmdbV0040GetJobsRequest

	// SlurmdbV0040GetJobsExecute executes the request
	//  @return V0040OpenapiSlurmdbdJobsResp
	SlurmdbV0040GetJobsExecute(r SlurmdbAPISlurmdbV0040GetJobsRequest) (*V0040OpenapiSlurmdbdJobsResp, *http.Response, error)

	/*
	SlurmdbV0040GetQos Get QOS list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040GetQosRequest
	*/
	SlurmdbV0040GetQos(ctx context.Context) SlurmdbAPISlurmdbV0040GetQosRequest

	// SlurmdbV0040GetQosExecute executes the request
	//  @return V0040OpenapiSlurmdbdQosResp
	SlurmdbV0040GetQosExecute(r SlurmdbAPISlurmdbV0040GetQosRequest) (*V0040OpenapiSlurmdbdQosResp, *http.Response, error)

	/*
	SlurmdbV0040GetSingleQos Get QOS info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param qos QOS name
	@return SlurmdbAPISlurmdbV0040GetSingleQosRequest
	*/
	SlurmdbV0040GetSingleQos(ctx context.Context, qos string) SlurmdbAPISlurmdbV0040GetSingleQosRequest

	// SlurmdbV0040GetSingleQosExecute executes the request
	//  @return V0040OpenapiSlurmdbdQosResp
	SlurmdbV0040GetSingleQosExecute(r SlurmdbAPISlurmdbV0040GetSingleQosRequest) (*V0040OpenapiSlurmdbdQosResp, *http.Response, error)

	/*
	SlurmdbV0040GetTres Get TRES info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040GetTresRequest
	*/
	SlurmdbV0040GetTres(ctx context.Context) SlurmdbAPISlurmdbV0040GetTresRequest

	// SlurmdbV0040GetTresExecute executes the request
	//  @return V0040OpenapiTresResp
	SlurmdbV0040GetTresExecute(r SlurmdbAPISlurmdbV0040GetTresRequest) (*V0040OpenapiTresResp, *http.Response, error)

	/*
	SlurmdbV0040GetUser Get user info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name User name
	@return SlurmdbAPISlurmdbV0040GetUserRequest
	*/
	SlurmdbV0040GetUser(ctx context.Context, name string) SlurmdbAPISlurmdbV0040GetUserRequest

	// SlurmdbV0040GetUserExecute executes the request
	//  @return V0040OpenapiUsersResp
	SlurmdbV0040GetUserExecute(r SlurmdbAPISlurmdbV0040GetUserRequest) (*V0040OpenapiUsersResp, *http.Response, error)

	/*
	SlurmdbV0040GetUsers Get user list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040GetUsersRequest
	*/
	SlurmdbV0040GetUsers(ctx context.Context) SlurmdbAPISlurmdbV0040GetUsersRequest

	// SlurmdbV0040GetUsersExecute executes the request
	//  @return V0040OpenapiUsersResp
	SlurmdbV0040GetUsersExecute(r SlurmdbAPISlurmdbV0040GetUsersRequest) (*V0040OpenapiUsersResp, *http.Response, error)

	/*
	SlurmdbV0040GetWckey Get wckey info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id wckey id
	@return SlurmdbAPISlurmdbV0040GetWckeyRequest
	*/
	SlurmdbV0040GetWckey(ctx context.Context, id string) SlurmdbAPISlurmdbV0040GetWckeyRequest

	// SlurmdbV0040GetWckeyExecute executes the request
	//  @return V0040OpenapiWckeyResp
	SlurmdbV0040GetWckeyExecute(r SlurmdbAPISlurmdbV0040GetWckeyRequest) (*V0040OpenapiWckeyResp, *http.Response, error)

	/*
	SlurmdbV0040GetWckeys Get wckey list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040GetWckeysRequest
	*/
	SlurmdbV0040GetWckeys(ctx context.Context) SlurmdbAPISlurmdbV0040GetWckeysRequest

	// SlurmdbV0040GetWckeysExecute executes the request
	//  @return V0040OpenapiWckeyResp
	SlurmdbV0040GetWckeysExecute(r SlurmdbAPISlurmdbV0040GetWckeysRequest) (*V0040OpenapiWckeyResp, *http.Response, error)

	/*
	SlurmdbV0040PostAccounts Add/update list of accounts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040PostAccountsRequest
	*/
	SlurmdbV0040PostAccounts(ctx context.Context) SlurmdbAPISlurmdbV0040PostAccountsRequest

	// SlurmdbV0040PostAccountsExecute executes the request
	//  @return V0040OpenapiResp
	SlurmdbV0040PostAccountsExecute(r SlurmdbAPISlurmdbV0040PostAccountsRequest) (*V0040OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0040PostAccountsAssociation Add accounts with conditional association

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040PostAccountsAssociationRequest
	*/
	SlurmdbV0040PostAccountsAssociation(ctx context.Context) SlurmdbAPISlurmdbV0040PostAccountsAssociationRequest

	// SlurmdbV0040PostAccountsAssociationExecute executes the request
	//  @return V0040OpenapiAccountsAddCondRespStr
	SlurmdbV0040PostAccountsAssociationExecute(r SlurmdbAPISlurmdbV0040PostAccountsAssociationRequest) (*V0040OpenapiAccountsAddCondRespStr, *http.Response, error)

	/*
	SlurmdbV0040PostAssociations Set associations info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040PostAssociationsRequest
	*/
	SlurmdbV0040PostAssociations(ctx context.Context) SlurmdbAPISlurmdbV0040PostAssociationsRequest

	// SlurmdbV0040PostAssociationsExecute executes the request
	//  @return V0040OpenapiResp
	SlurmdbV0040PostAssociationsExecute(r SlurmdbAPISlurmdbV0040PostAssociationsRequest) (*V0040OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0040PostClusters Get cluster list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040PostClustersRequest
	*/
	SlurmdbV0040PostClusters(ctx context.Context) SlurmdbAPISlurmdbV0040PostClustersRequest

	// SlurmdbV0040PostClustersExecute executes the request
	//  @return V0040OpenapiResp
	SlurmdbV0040PostClustersExecute(r SlurmdbAPISlurmdbV0040PostClustersRequest) (*V0040OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0040PostConfig Load all configuration information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040PostConfigRequest
	*/
	SlurmdbV0040PostConfig(ctx context.Context) SlurmdbAPISlurmdbV0040PostConfigRequest

	// SlurmdbV0040PostConfigExecute executes the request
	//  @return V0040OpenapiResp
	SlurmdbV0040PostConfigExecute(r SlurmdbAPISlurmdbV0040PostConfigRequest) (*V0040OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0040PostQos Add or update QOSs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040PostQosRequest
	*/
	SlurmdbV0040PostQos(ctx context.Context) SlurmdbAPISlurmdbV0040PostQosRequest

	// SlurmdbV0040PostQosExecute executes the request
	//  @return V0040OpenapiResp
	SlurmdbV0040PostQosExecute(r SlurmdbAPISlurmdbV0040PostQosRequest) (*V0040OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0040PostTres Add TRES

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040PostTresRequest
	*/
	SlurmdbV0040PostTres(ctx context.Context) SlurmdbAPISlurmdbV0040PostTresRequest

	// SlurmdbV0040PostTresExecute executes the request
	//  @return V0040OpenapiResp
	SlurmdbV0040PostTresExecute(r SlurmdbAPISlurmdbV0040PostTresRequest) (*V0040OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0040PostUsers Update users

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040PostUsersRequest
	*/
	SlurmdbV0040PostUsers(ctx context.Context) SlurmdbAPISlurmdbV0040PostUsersRequest

	// SlurmdbV0040PostUsersExecute executes the request
	//  @return V0040OpenapiResp
	SlurmdbV0040PostUsersExecute(r SlurmdbAPISlurmdbV0040PostUsersRequest) (*V0040OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0040PostUsersAssociation Add users with conditional association

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040PostUsersAssociationRequest
	*/
	SlurmdbV0040PostUsersAssociation(ctx context.Context) SlurmdbAPISlurmdbV0040PostUsersAssociationRequest

	// SlurmdbV0040PostUsersAssociationExecute executes the request
	//  @return V0040OpenapiUsersAddCondRespStr
	SlurmdbV0040PostUsersAssociationExecute(r SlurmdbAPISlurmdbV0040PostUsersAssociationRequest) (*V0040OpenapiUsersAddCondRespStr, *http.Response, error)

	/*
	SlurmdbV0040PostWckeys Add or update wckeys

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0040PostWckeysRequest
	*/
	SlurmdbV0040PostWckeys(ctx context.Context) SlurmdbAPISlurmdbV0040PostWckeysRequest

	// SlurmdbV0040PostWckeysExecute executes the request
	//  @return V0040OpenapiResp
	SlurmdbV0040PostWckeysExecute(r SlurmdbAPISlurmdbV0040PostWckeysRequest) (*V0040OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0041DeleteAccount Delete account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountName Account name
	@return SlurmdbAPISlurmdbV0041DeleteAccountRequest
	*/
	SlurmdbV0041DeleteAccount(ctx context.Context, accountName string) SlurmdbAPISlurmdbV0041DeleteAccountRequest

	// SlurmdbV0041DeleteAccountExecute executes the request
	//  @return V0041OpenapiAccountsRemovedResp
	SlurmdbV0041DeleteAccountExecute(r SlurmdbAPISlurmdbV0041DeleteAccountRequest) (*V0041OpenapiAccountsRemovedResp, *http.Response, error)

	/*
	SlurmdbV0041DeleteAssociation Delete association

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041DeleteAssociationRequest
	*/
	SlurmdbV0041DeleteAssociation(ctx context.Context) SlurmdbAPISlurmdbV0041DeleteAssociationRequest

	// SlurmdbV0041DeleteAssociationExecute executes the request
	//  @return V0041OpenapiAssocsRemovedResp
	SlurmdbV0041DeleteAssociationExecute(r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) (*V0041OpenapiAssocsRemovedResp, *http.Response, error)

	/*
	SlurmdbV0041DeleteAssociations Delete associations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041DeleteAssociationsRequest
	*/
	SlurmdbV0041DeleteAssociations(ctx context.Context) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest

	// SlurmdbV0041DeleteAssociationsExecute executes the request
	//  @return V0041OpenapiAssocsRemovedResp
	SlurmdbV0041DeleteAssociationsExecute(r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) (*V0041OpenapiAssocsRemovedResp, *http.Response, error)

	/*
	SlurmdbV0041DeleteCluster Delete cluster

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterName Cluster name
	@return SlurmdbAPISlurmdbV0041DeleteClusterRequest
	*/
	SlurmdbV0041DeleteCluster(ctx context.Context, clusterName string) SlurmdbAPISlurmdbV0041DeleteClusterRequest

	// SlurmdbV0041DeleteClusterExecute executes the request
	//  @return V0041OpenapiClustersRemovedResp
	SlurmdbV0041DeleteClusterExecute(r SlurmdbAPISlurmdbV0041DeleteClusterRequest) (*V0041OpenapiClustersRemovedResp, *http.Response, error)

	/*
	SlurmdbV0041DeleteSingleQos Delete QOS

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param qos QOS name
	@return SlurmdbAPISlurmdbV0041DeleteSingleQosRequest
	*/
	SlurmdbV0041DeleteSingleQos(ctx context.Context, qos string) SlurmdbAPISlurmdbV0041DeleteSingleQosRequest

	// SlurmdbV0041DeleteSingleQosExecute executes the request
	//  @return V0041OpenapiSlurmdbdQosRemovedResp
	SlurmdbV0041DeleteSingleQosExecute(r SlurmdbAPISlurmdbV0041DeleteSingleQosRequest) (*V0041OpenapiSlurmdbdQosRemovedResp, *http.Response, error)

	/*
	SlurmdbV0041DeleteUser Delete user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name User name
	@return SlurmdbAPISlurmdbV0041DeleteUserRequest
	*/
	SlurmdbV0041DeleteUser(ctx context.Context, name string) SlurmdbAPISlurmdbV0041DeleteUserRequest

	// SlurmdbV0041DeleteUserExecute executes the request
	//  @return V0041OpenapiResp
	SlurmdbV0041DeleteUserExecute(r SlurmdbAPISlurmdbV0041DeleteUserRequest) (*V0041OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0041DeleteWckey Delete wckey

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id wckey id
	@return SlurmdbAPISlurmdbV0041DeleteWckeyRequest
	*/
	SlurmdbV0041DeleteWckey(ctx context.Context, id string) SlurmdbAPISlurmdbV0041DeleteWckeyRequest

	// SlurmdbV0041DeleteWckeyExecute executes the request
	//  @return V0041OpenapiWckeyRemovedResp
	SlurmdbV0041DeleteWckeyExecute(r SlurmdbAPISlurmdbV0041DeleteWckeyRequest) (*V0041OpenapiWckeyRemovedResp, *http.Response, error)

	/*
	SlurmdbV0041GetAccount Get account info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountName Account name
	@return SlurmdbAPISlurmdbV0041GetAccountRequest
	*/
	SlurmdbV0041GetAccount(ctx context.Context, accountName string) SlurmdbAPISlurmdbV0041GetAccountRequest

	// SlurmdbV0041GetAccountExecute executes the request
	//  @return V0041OpenapiAccountsResp
	SlurmdbV0041GetAccountExecute(r SlurmdbAPISlurmdbV0041GetAccountRequest) (*V0041OpenapiAccountsResp, *http.Response, error)

	/*
	SlurmdbV0041GetAccounts Get account list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041GetAccountsRequest
	*/
	SlurmdbV0041GetAccounts(ctx context.Context) SlurmdbAPISlurmdbV0041GetAccountsRequest

	// SlurmdbV0041GetAccountsExecute executes the request
	//  @return V0041OpenapiAccountsResp
	SlurmdbV0041GetAccountsExecute(r SlurmdbAPISlurmdbV0041GetAccountsRequest) (*V0041OpenapiAccountsResp, *http.Response, error)

	/*
	SlurmdbV0041GetAssociation Get association info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041GetAssociationRequest
	*/
	SlurmdbV0041GetAssociation(ctx context.Context) SlurmdbAPISlurmdbV0041GetAssociationRequest

	// SlurmdbV0041GetAssociationExecute executes the request
	//  @return V0041OpenapiAssocsResp
	SlurmdbV0041GetAssociationExecute(r SlurmdbAPISlurmdbV0041GetAssociationRequest) (*V0041OpenapiAssocsResp, *http.Response, error)

	/*
	SlurmdbV0041GetAssociations Get association list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041GetAssociationsRequest
	*/
	SlurmdbV0041GetAssociations(ctx context.Context) SlurmdbAPISlurmdbV0041GetAssociationsRequest

	// SlurmdbV0041GetAssociationsExecute executes the request
	//  @return V0041OpenapiAssocsResp
	SlurmdbV0041GetAssociationsExecute(r SlurmdbAPISlurmdbV0041GetAssociationsRequest) (*V0041OpenapiAssocsResp, *http.Response, error)

	/*
	SlurmdbV0041GetCluster Get cluster info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterName Cluster name
	@return SlurmdbAPISlurmdbV0041GetClusterRequest
	*/
	SlurmdbV0041GetCluster(ctx context.Context, clusterName string) SlurmdbAPISlurmdbV0041GetClusterRequest

	// SlurmdbV0041GetClusterExecute executes the request
	//  @return V0041OpenapiClustersResp
	SlurmdbV0041GetClusterExecute(r SlurmdbAPISlurmdbV0041GetClusterRequest) (*V0041OpenapiClustersResp, *http.Response, error)

	/*
	SlurmdbV0041GetClusters Get cluster list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041GetClustersRequest
	*/
	SlurmdbV0041GetClusters(ctx context.Context) SlurmdbAPISlurmdbV0041GetClustersRequest

	// SlurmdbV0041GetClustersExecute executes the request
	//  @return V0041OpenapiClustersResp
	SlurmdbV0041GetClustersExecute(r SlurmdbAPISlurmdbV0041GetClustersRequest) (*V0041OpenapiClustersResp, *http.Response, error)

	/*
	SlurmdbV0041GetConfig Dump all configuration information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041GetConfigRequest
	*/
	SlurmdbV0041GetConfig(ctx context.Context) SlurmdbAPISlurmdbV0041GetConfigRequest

	// SlurmdbV0041GetConfigExecute executes the request
	//  @return V0041OpenapiSlurmdbdConfigResp
	SlurmdbV0041GetConfigExecute(r SlurmdbAPISlurmdbV0041GetConfigRequest) (*V0041OpenapiSlurmdbdConfigResp, *http.Response, error)

	/*
	SlurmdbV0041GetDiag Get slurmdb diagnostics

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041GetDiagRequest
	*/
	SlurmdbV0041GetDiag(ctx context.Context) SlurmdbAPISlurmdbV0041GetDiagRequest

	// SlurmdbV0041GetDiagExecute executes the request
	//  @return V0041OpenapiSlurmdbdStatsResp
	SlurmdbV0041GetDiagExecute(r SlurmdbAPISlurmdbV0041GetDiagRequest) (*V0041OpenapiSlurmdbdStatsResp, *http.Response, error)

	/*
	SlurmdbV0041GetInstance Get instance info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041GetInstanceRequest
	*/
	SlurmdbV0041GetInstance(ctx context.Context) SlurmdbAPISlurmdbV0041GetInstanceRequest

	// SlurmdbV0041GetInstanceExecute executes the request
	//  @return V0041OpenapiInstancesResp
	SlurmdbV0041GetInstanceExecute(r SlurmdbAPISlurmdbV0041GetInstanceRequest) (*V0041OpenapiInstancesResp, *http.Response, error)

	/*
	SlurmdbV0041GetInstances Get instance list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041GetInstancesRequest
	*/
	SlurmdbV0041GetInstances(ctx context.Context) SlurmdbAPISlurmdbV0041GetInstancesRequest

	// SlurmdbV0041GetInstancesExecute executes the request
	//  @return V0041OpenapiInstancesResp
	SlurmdbV0041GetInstancesExecute(r SlurmdbAPISlurmdbV0041GetInstancesRequest) (*V0041OpenapiInstancesResp, *http.Response, error)

	/*
	SlurmdbV0041GetJob Get job info

	This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId Job id
	@return SlurmdbAPISlurmdbV0041GetJobRequest
	*/
	SlurmdbV0041GetJob(ctx context.Context, jobId string) SlurmdbAPISlurmdbV0041GetJobRequest

	// SlurmdbV0041GetJobExecute executes the request
	//  @return V0041OpenapiSlurmdbdJobsResp
	SlurmdbV0041GetJobExecute(r SlurmdbAPISlurmdbV0041GetJobRequest) (*V0041OpenapiSlurmdbdJobsResp, *http.Response, error)

	/*
	SlurmdbV0041GetJobs Get job list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041GetJobsRequest
	*/
	SlurmdbV0041GetJobs(ctx context.Context) SlurmdbAPISlurmdbV0041GetJobsRequest

	// SlurmdbV0041GetJobsExecute executes the request
	//  @return V0041OpenapiSlurmdbdJobsResp
	SlurmdbV0041GetJobsExecute(r SlurmdbAPISlurmdbV0041GetJobsRequest) (*V0041OpenapiSlurmdbdJobsResp, *http.Response, error)

	/*
	SlurmdbV0041GetQos Get QOS list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041GetQosRequest
	*/
	SlurmdbV0041GetQos(ctx context.Context) SlurmdbAPISlurmdbV0041GetQosRequest

	// SlurmdbV0041GetQosExecute executes the request
	//  @return V0041OpenapiSlurmdbdQosResp
	SlurmdbV0041GetQosExecute(r SlurmdbAPISlurmdbV0041GetQosRequest) (*V0041OpenapiSlurmdbdQosResp, *http.Response, error)

	/*
	SlurmdbV0041GetSingleQos Get QOS info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param qos QOS name
	@return SlurmdbAPISlurmdbV0041GetSingleQosRequest
	*/
	SlurmdbV0041GetSingleQos(ctx context.Context, qos string) SlurmdbAPISlurmdbV0041GetSingleQosRequest

	// SlurmdbV0041GetSingleQosExecute executes the request
	//  @return V0041OpenapiSlurmdbdQosResp
	SlurmdbV0041GetSingleQosExecute(r SlurmdbAPISlurmdbV0041GetSingleQosRequest) (*V0041OpenapiSlurmdbdQosResp, *http.Response, error)

	/*
	SlurmdbV0041GetTres Get TRES info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041GetTresRequest
	*/
	SlurmdbV0041GetTres(ctx context.Context) SlurmdbAPISlurmdbV0041GetTresRequest

	// SlurmdbV0041GetTresExecute executes the request
	//  @return V0041OpenapiTresResp
	SlurmdbV0041GetTresExecute(r SlurmdbAPISlurmdbV0041GetTresRequest) (*V0041OpenapiTresResp, *http.Response, error)

	/*
	SlurmdbV0041GetUser Get user info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name User name
	@return SlurmdbAPISlurmdbV0041GetUserRequest
	*/
	SlurmdbV0041GetUser(ctx context.Context, name string) SlurmdbAPISlurmdbV0041GetUserRequest

	// SlurmdbV0041GetUserExecute executes the request
	//  @return V0041OpenapiUsersResp
	SlurmdbV0041GetUserExecute(r SlurmdbAPISlurmdbV0041GetUserRequest) (*V0041OpenapiUsersResp, *http.Response, error)

	/*
	SlurmdbV0041GetUsers Get user list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041GetUsersRequest
	*/
	SlurmdbV0041GetUsers(ctx context.Context) SlurmdbAPISlurmdbV0041GetUsersRequest

	// SlurmdbV0041GetUsersExecute executes the request
	//  @return V0041OpenapiUsersResp
	SlurmdbV0041GetUsersExecute(r SlurmdbAPISlurmdbV0041GetUsersRequest) (*V0041OpenapiUsersResp, *http.Response, error)

	/*
	SlurmdbV0041GetWckey Get wckey info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id wckey id
	@return SlurmdbAPISlurmdbV0041GetWckeyRequest
	*/
	SlurmdbV0041GetWckey(ctx context.Context, id string) SlurmdbAPISlurmdbV0041GetWckeyRequest

	// SlurmdbV0041GetWckeyExecute executes the request
	//  @return V0041OpenapiWckeyResp
	SlurmdbV0041GetWckeyExecute(r SlurmdbAPISlurmdbV0041GetWckeyRequest) (*V0041OpenapiWckeyResp, *http.Response, error)

	/*
	SlurmdbV0041GetWckeys Get wckey list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041GetWckeysRequest
	*/
	SlurmdbV0041GetWckeys(ctx context.Context) SlurmdbAPISlurmdbV0041GetWckeysRequest

	// SlurmdbV0041GetWckeysExecute executes the request
	//  @return V0041OpenapiWckeyResp
	SlurmdbV0041GetWckeysExecute(r SlurmdbAPISlurmdbV0041GetWckeysRequest) (*V0041OpenapiWckeyResp, *http.Response, error)

	/*
	SlurmdbV0041PostAccounts Add/update list of accounts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041PostAccountsRequest
	*/
	SlurmdbV0041PostAccounts(ctx context.Context) SlurmdbAPISlurmdbV0041PostAccountsRequest

	// SlurmdbV0041PostAccountsExecute executes the request
	//  @return V0041OpenapiResp
	SlurmdbV0041PostAccountsExecute(r SlurmdbAPISlurmdbV0041PostAccountsRequest) (*V0041OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0041PostAccountsAssociation Add accounts with conditional association

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041PostAccountsAssociationRequest
	*/
	SlurmdbV0041PostAccountsAssociation(ctx context.Context) SlurmdbAPISlurmdbV0041PostAccountsAssociationRequest

	// SlurmdbV0041PostAccountsAssociationExecute executes the request
	//  @return V0041OpenapiAccountsAddCondRespStr
	SlurmdbV0041PostAccountsAssociationExecute(r SlurmdbAPISlurmdbV0041PostAccountsAssociationRequest) (*V0041OpenapiAccountsAddCondRespStr, *http.Response, error)

	/*
	SlurmdbV0041PostAssociations Set associations info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041PostAssociationsRequest
	*/
	SlurmdbV0041PostAssociations(ctx context.Context) SlurmdbAPISlurmdbV0041PostAssociationsRequest

	// SlurmdbV0041PostAssociationsExecute executes the request
	//  @return V0041OpenapiResp
	SlurmdbV0041PostAssociationsExecute(r SlurmdbAPISlurmdbV0041PostAssociationsRequest) (*V0041OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0041PostClusters Get cluster list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041PostClustersRequest
	*/
	SlurmdbV0041PostClusters(ctx context.Context) SlurmdbAPISlurmdbV0041PostClustersRequest

	// SlurmdbV0041PostClustersExecute executes the request
	//  @return V0041OpenapiResp
	SlurmdbV0041PostClustersExecute(r SlurmdbAPISlurmdbV0041PostClustersRequest) (*V0041OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0041PostConfig Load all configuration information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041PostConfigRequest
	*/
	SlurmdbV0041PostConfig(ctx context.Context) SlurmdbAPISlurmdbV0041PostConfigRequest

	// SlurmdbV0041PostConfigExecute executes the request
	//  @return V0041OpenapiResp
	SlurmdbV0041PostConfigExecute(r SlurmdbAPISlurmdbV0041PostConfigRequest) (*V0041OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0041PostQos Add or update QOSs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041PostQosRequest
	*/
	SlurmdbV0041PostQos(ctx context.Context) SlurmdbAPISlurmdbV0041PostQosRequest

	// SlurmdbV0041PostQosExecute executes the request
	//  @return V0041OpenapiResp
	SlurmdbV0041PostQosExecute(r SlurmdbAPISlurmdbV0041PostQosRequest) (*V0041OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0041PostTres Add TRES

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041PostTresRequest
	*/
	SlurmdbV0041PostTres(ctx context.Context) SlurmdbAPISlurmdbV0041PostTresRequest

	// SlurmdbV0041PostTresExecute executes the request
	//  @return V0041OpenapiResp
	SlurmdbV0041PostTresExecute(r SlurmdbAPISlurmdbV0041PostTresRequest) (*V0041OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0041PostUsers Update users

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041PostUsersRequest
	*/
	SlurmdbV0041PostUsers(ctx context.Context) SlurmdbAPISlurmdbV0041PostUsersRequest

	// SlurmdbV0041PostUsersExecute executes the request
	//  @return V0041OpenapiResp
	SlurmdbV0041PostUsersExecute(r SlurmdbAPISlurmdbV0041PostUsersRequest) (*V0041OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0041PostUsersAssociation Add users with conditional association

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041PostUsersAssociationRequest
	*/
	SlurmdbV0041PostUsersAssociation(ctx context.Context) SlurmdbAPISlurmdbV0041PostUsersAssociationRequest

	// SlurmdbV0041PostUsersAssociationExecute executes the request
	//  @return V0041OpenapiUsersAddCondRespStr
	SlurmdbV0041PostUsersAssociationExecute(r SlurmdbAPISlurmdbV0041PostUsersAssociationRequest) (*V0041OpenapiUsersAddCondRespStr, *http.Response, error)

	/*
	SlurmdbV0041PostWckeys Add or update wckeys

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0041PostWckeysRequest
	*/
	SlurmdbV0041PostWckeys(ctx context.Context) SlurmdbAPISlurmdbV0041PostWckeysRequest

	// SlurmdbV0041PostWckeysExecute executes the request
	//  @return V0041OpenapiResp
	SlurmdbV0041PostWckeysExecute(r SlurmdbAPISlurmdbV0041PostWckeysRequest) (*V0041OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0042DeleteAccount Delete account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountName Account name
	@return SlurmdbAPISlurmdbV0042DeleteAccountRequest
	*/
	SlurmdbV0042DeleteAccount(ctx context.Context, accountName string) SlurmdbAPISlurmdbV0042DeleteAccountRequest

	// SlurmdbV0042DeleteAccountExecute executes the request
	//  @return V0042OpenapiAccountsRemovedResp
	SlurmdbV0042DeleteAccountExecute(r SlurmdbAPISlurmdbV0042DeleteAccountRequest) (*V0042OpenapiAccountsRemovedResp, *http.Response, error)

	/*
	SlurmdbV0042DeleteAssociation Delete association

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042DeleteAssociationRequest
	*/
	SlurmdbV0042DeleteAssociation(ctx context.Context) SlurmdbAPISlurmdbV0042DeleteAssociationRequest

	// SlurmdbV0042DeleteAssociationExecute executes the request
	//  @return V0042OpenapiAssocsRemovedResp
	SlurmdbV0042DeleteAssociationExecute(r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) (*V0042OpenapiAssocsRemovedResp, *http.Response, error)

	/*
	SlurmdbV0042DeleteAssociations Delete associations

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042DeleteAssociationsRequest
	*/
	SlurmdbV0042DeleteAssociations(ctx context.Context) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest

	// SlurmdbV0042DeleteAssociationsExecute executes the request
	//  @return V0042OpenapiAssocsRemovedResp
	SlurmdbV0042DeleteAssociationsExecute(r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) (*V0042OpenapiAssocsRemovedResp, *http.Response, error)

	/*
	SlurmdbV0042DeleteCluster Delete cluster

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterName Cluster name
	@return SlurmdbAPISlurmdbV0042DeleteClusterRequest
	*/
	SlurmdbV0042DeleteCluster(ctx context.Context, clusterName string) SlurmdbAPISlurmdbV0042DeleteClusterRequest

	// SlurmdbV0042DeleteClusterExecute executes the request
	//  @return V0042OpenapiClustersRemovedResp
	SlurmdbV0042DeleteClusterExecute(r SlurmdbAPISlurmdbV0042DeleteClusterRequest) (*V0042OpenapiClustersRemovedResp, *http.Response, error)

	/*
	SlurmdbV0042DeleteSingleQos Delete QOS

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param qos QOS name
	@return SlurmdbAPISlurmdbV0042DeleteSingleQosRequest
	*/
	SlurmdbV0042DeleteSingleQos(ctx context.Context, qos string) SlurmdbAPISlurmdbV0042DeleteSingleQosRequest

	// SlurmdbV0042DeleteSingleQosExecute executes the request
	//  @return V0042OpenapiSlurmdbdQosRemovedResp
	SlurmdbV0042DeleteSingleQosExecute(r SlurmdbAPISlurmdbV0042DeleteSingleQosRequest) (*V0042OpenapiSlurmdbdQosRemovedResp, *http.Response, error)

	/*
	SlurmdbV0042DeleteUser Delete user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name User name
	@return SlurmdbAPISlurmdbV0042DeleteUserRequest
	*/
	SlurmdbV0042DeleteUser(ctx context.Context, name string) SlurmdbAPISlurmdbV0042DeleteUserRequest

	// SlurmdbV0042DeleteUserExecute executes the request
	//  @return V0042OpenapiResp
	SlurmdbV0042DeleteUserExecute(r SlurmdbAPISlurmdbV0042DeleteUserRequest) (*V0042OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0042DeleteWckey Delete wckey

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id WCKey ID
	@return SlurmdbAPISlurmdbV0042DeleteWckeyRequest
	*/
	SlurmdbV0042DeleteWckey(ctx context.Context, id string) SlurmdbAPISlurmdbV0042DeleteWckeyRequest

	// SlurmdbV0042DeleteWckeyExecute executes the request
	//  @return V0042OpenapiWckeyRemovedResp
	SlurmdbV0042DeleteWckeyExecute(r SlurmdbAPISlurmdbV0042DeleteWckeyRequest) (*V0042OpenapiWckeyRemovedResp, *http.Response, error)

	/*
	SlurmdbV0042GetAccount Get account info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param accountName Account name
	@return SlurmdbAPISlurmdbV0042GetAccountRequest
	*/
	SlurmdbV0042GetAccount(ctx context.Context, accountName string) SlurmdbAPISlurmdbV0042GetAccountRequest

	// SlurmdbV0042GetAccountExecute executes the request
	//  @return V0042OpenapiAccountsResp
	SlurmdbV0042GetAccountExecute(r SlurmdbAPISlurmdbV0042GetAccountRequest) (*V0042OpenapiAccountsResp, *http.Response, error)

	/*
	SlurmdbV0042GetAccounts Get account list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042GetAccountsRequest
	*/
	SlurmdbV0042GetAccounts(ctx context.Context) SlurmdbAPISlurmdbV0042GetAccountsRequest

	// SlurmdbV0042GetAccountsExecute executes the request
	//  @return V0042OpenapiAccountsResp
	SlurmdbV0042GetAccountsExecute(r SlurmdbAPISlurmdbV0042GetAccountsRequest) (*V0042OpenapiAccountsResp, *http.Response, error)

	/*
	SlurmdbV0042GetAssociation Get association info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042GetAssociationRequest
	*/
	SlurmdbV0042GetAssociation(ctx context.Context) SlurmdbAPISlurmdbV0042GetAssociationRequest

	// SlurmdbV0042GetAssociationExecute executes the request
	//  @return V0042OpenapiAssocsResp
	SlurmdbV0042GetAssociationExecute(r SlurmdbAPISlurmdbV0042GetAssociationRequest) (*V0042OpenapiAssocsResp, *http.Response, error)

	/*
	SlurmdbV0042GetAssociations Get association list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042GetAssociationsRequest
	*/
	SlurmdbV0042GetAssociations(ctx context.Context) SlurmdbAPISlurmdbV0042GetAssociationsRequest

	// SlurmdbV0042GetAssociationsExecute executes the request
	//  @return V0042OpenapiAssocsResp
	SlurmdbV0042GetAssociationsExecute(r SlurmdbAPISlurmdbV0042GetAssociationsRequest) (*V0042OpenapiAssocsResp, *http.Response, error)

	/*
	SlurmdbV0042GetCluster Get cluster info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterName Cluster name
	@return SlurmdbAPISlurmdbV0042GetClusterRequest
	*/
	SlurmdbV0042GetCluster(ctx context.Context, clusterName string) SlurmdbAPISlurmdbV0042GetClusterRequest

	// SlurmdbV0042GetClusterExecute executes the request
	//  @return V0042OpenapiClustersResp
	SlurmdbV0042GetClusterExecute(r SlurmdbAPISlurmdbV0042GetClusterRequest) (*V0042OpenapiClustersResp, *http.Response, error)

	/*
	SlurmdbV0042GetClusters Get cluster list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042GetClustersRequest
	*/
	SlurmdbV0042GetClusters(ctx context.Context) SlurmdbAPISlurmdbV0042GetClustersRequest

	// SlurmdbV0042GetClustersExecute executes the request
	//  @return V0042OpenapiClustersResp
	SlurmdbV0042GetClustersExecute(r SlurmdbAPISlurmdbV0042GetClustersRequest) (*V0042OpenapiClustersResp, *http.Response, error)

	/*
	SlurmdbV0042GetConfig Dump all configuration information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042GetConfigRequest
	*/
	SlurmdbV0042GetConfig(ctx context.Context) SlurmdbAPISlurmdbV0042GetConfigRequest

	// SlurmdbV0042GetConfigExecute executes the request
	//  @return V0042OpenapiSlurmdbdConfigResp
	SlurmdbV0042GetConfigExecute(r SlurmdbAPISlurmdbV0042GetConfigRequest) (*V0042OpenapiSlurmdbdConfigResp, *http.Response, error)

	/*
	SlurmdbV0042GetDiag Get slurmdb diagnostics

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042GetDiagRequest
	*/
	SlurmdbV0042GetDiag(ctx context.Context) SlurmdbAPISlurmdbV0042GetDiagRequest

	// SlurmdbV0042GetDiagExecute executes the request
	//  @return V0042OpenapiSlurmdbdStatsResp
	SlurmdbV0042GetDiagExecute(r SlurmdbAPISlurmdbV0042GetDiagRequest) (*V0042OpenapiSlurmdbdStatsResp, *http.Response, error)

	/*
	SlurmdbV0042GetInstance Get instance info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042GetInstanceRequest
	*/
	SlurmdbV0042GetInstance(ctx context.Context) SlurmdbAPISlurmdbV0042GetInstanceRequest

	// SlurmdbV0042GetInstanceExecute executes the request
	//  @return V0042OpenapiInstancesResp
	SlurmdbV0042GetInstanceExecute(r SlurmdbAPISlurmdbV0042GetInstanceRequest) (*V0042OpenapiInstancesResp, *http.Response, error)

	/*
	SlurmdbV0042GetInstances Get instance list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042GetInstancesRequest
	*/
	SlurmdbV0042GetInstances(ctx context.Context) SlurmdbAPISlurmdbV0042GetInstancesRequest

	// SlurmdbV0042GetInstancesExecute executes the request
	//  @return V0042OpenapiInstancesResp
	SlurmdbV0042GetInstancesExecute(r SlurmdbAPISlurmdbV0042GetInstancesRequest) (*V0042OpenapiInstancesResp, *http.Response, error)

	/*
	SlurmdbV0042GetJob Get job info

	This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param jobId Job ID
	@return SlurmdbAPISlurmdbV0042GetJobRequest
	*/
	SlurmdbV0042GetJob(ctx context.Context, jobId string) SlurmdbAPISlurmdbV0042GetJobRequest

	// SlurmdbV0042GetJobExecute executes the request
	//  @return V0042OpenapiSlurmdbdJobsResp
	SlurmdbV0042GetJobExecute(r SlurmdbAPISlurmdbV0042GetJobRequest) (*V0042OpenapiSlurmdbdJobsResp, *http.Response, error)

	/*
	SlurmdbV0042GetJobs Get job list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042GetJobsRequest
	*/
	SlurmdbV0042GetJobs(ctx context.Context) SlurmdbAPISlurmdbV0042GetJobsRequest

	// SlurmdbV0042GetJobsExecute executes the request
	//  @return V0042OpenapiSlurmdbdJobsResp
	SlurmdbV0042GetJobsExecute(r SlurmdbAPISlurmdbV0042GetJobsRequest) (*V0042OpenapiSlurmdbdJobsResp, *http.Response, error)

	/*
	SlurmdbV0042GetPing ping test

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042GetPingRequest
	*/
	SlurmdbV0042GetPing(ctx context.Context) SlurmdbAPISlurmdbV0042GetPingRequest

	// SlurmdbV0042GetPingExecute executes the request
	//  @return V0042OpenapiSlurmdbdPingResp
	SlurmdbV0042GetPingExecute(r SlurmdbAPISlurmdbV0042GetPingRequest) (*V0042OpenapiSlurmdbdPingResp, *http.Response, error)

	/*
	SlurmdbV0042GetQos Get QOS list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042GetQosRequest
	*/
	SlurmdbV0042GetQos(ctx context.Context) SlurmdbAPISlurmdbV0042GetQosRequest

	// SlurmdbV0042GetQosExecute executes the request
	//  @return V0042OpenapiSlurmdbdQosResp
	SlurmdbV0042GetQosExecute(r SlurmdbAPISlurmdbV0042GetQosRequest) (*V0042OpenapiSlurmdbdQosResp, *http.Response, error)

	/*
	SlurmdbV0042GetSingleQos Get QOS info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param qos QOS name
	@return SlurmdbAPISlurmdbV0042GetSingleQosRequest
	*/
	SlurmdbV0042GetSingleQos(ctx context.Context, qos string) SlurmdbAPISlurmdbV0042GetSingleQosRequest

	// SlurmdbV0042GetSingleQosExecute executes the request
	//  @return V0042OpenapiSlurmdbdQosResp
	SlurmdbV0042GetSingleQosExecute(r SlurmdbAPISlurmdbV0042GetSingleQosRequest) (*V0042OpenapiSlurmdbdQosResp, *http.Response, error)

	/*
	SlurmdbV0042GetTres Get TRES info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042GetTresRequest
	*/
	SlurmdbV0042GetTres(ctx context.Context) SlurmdbAPISlurmdbV0042GetTresRequest

	// SlurmdbV0042GetTresExecute executes the request
	//  @return V0042OpenapiTresResp
	SlurmdbV0042GetTresExecute(r SlurmdbAPISlurmdbV0042GetTresRequest) (*V0042OpenapiTresResp, *http.Response, error)

	/*
	SlurmdbV0042GetUser Get user info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name User name
	@return SlurmdbAPISlurmdbV0042GetUserRequest
	*/
	SlurmdbV0042GetUser(ctx context.Context, name string) SlurmdbAPISlurmdbV0042GetUserRequest

	// SlurmdbV0042GetUserExecute executes the request
	//  @return V0042OpenapiUsersResp
	SlurmdbV0042GetUserExecute(r SlurmdbAPISlurmdbV0042GetUserRequest) (*V0042OpenapiUsersResp, *http.Response, error)

	/*
	SlurmdbV0042GetUsers Get user list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042GetUsersRequest
	*/
	SlurmdbV0042GetUsers(ctx context.Context) SlurmdbAPISlurmdbV0042GetUsersRequest

	// SlurmdbV0042GetUsersExecute executes the request
	//  @return V0042OpenapiUsersResp
	SlurmdbV0042GetUsersExecute(r SlurmdbAPISlurmdbV0042GetUsersRequest) (*V0042OpenapiUsersResp, *http.Response, error)

	/*
	SlurmdbV0042GetWckey Get wckey info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id WCKey ID
	@return SlurmdbAPISlurmdbV0042GetWckeyRequest
	*/
	SlurmdbV0042GetWckey(ctx context.Context, id string) SlurmdbAPISlurmdbV0042GetWckeyRequest

	// SlurmdbV0042GetWckeyExecute executes the request
	//  @return V0042OpenapiWckeyResp
	SlurmdbV0042GetWckeyExecute(r SlurmdbAPISlurmdbV0042GetWckeyRequest) (*V0042OpenapiWckeyResp, *http.Response, error)

	/*
	SlurmdbV0042GetWckeys Get wckey list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042GetWckeysRequest
	*/
	SlurmdbV0042GetWckeys(ctx context.Context) SlurmdbAPISlurmdbV0042GetWckeysRequest

	// SlurmdbV0042GetWckeysExecute executes the request
	//  @return V0042OpenapiWckeyResp
	SlurmdbV0042GetWckeysExecute(r SlurmdbAPISlurmdbV0042GetWckeysRequest) (*V0042OpenapiWckeyResp, *http.Response, error)

	/*
	SlurmdbV0042PostAccounts Add/update list of accounts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042PostAccountsRequest
	*/
	SlurmdbV0042PostAccounts(ctx context.Context) SlurmdbAPISlurmdbV0042PostAccountsRequest

	// SlurmdbV0042PostAccountsExecute executes the request
	//  @return V0042OpenapiResp
	SlurmdbV0042PostAccountsExecute(r SlurmdbAPISlurmdbV0042PostAccountsRequest) (*V0042OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0042PostAccountsAssociation Add accounts with conditional association

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042PostAccountsAssociationRequest
	*/
	SlurmdbV0042PostAccountsAssociation(ctx context.Context) SlurmdbAPISlurmdbV0042PostAccountsAssociationRequest

	// SlurmdbV0042PostAccountsAssociationExecute executes the request
	//  @return V0042OpenapiAccountsAddCondRespStr
	SlurmdbV0042PostAccountsAssociationExecute(r SlurmdbAPISlurmdbV0042PostAccountsAssociationRequest) (*V0042OpenapiAccountsAddCondRespStr, *http.Response, error)

	/*
	SlurmdbV0042PostAssociations Set associations info

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042PostAssociationsRequest
	*/
	SlurmdbV0042PostAssociations(ctx context.Context) SlurmdbAPISlurmdbV0042PostAssociationsRequest

	// SlurmdbV0042PostAssociationsExecute executes the request
	//  @return V0042OpenapiResp
	SlurmdbV0042PostAssociationsExecute(r SlurmdbAPISlurmdbV0042PostAssociationsRequest) (*V0042OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0042PostClusters Get cluster list

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042PostClustersRequest
	*/
	SlurmdbV0042PostClusters(ctx context.Context) SlurmdbAPISlurmdbV0042PostClustersRequest

	// SlurmdbV0042PostClustersExecute executes the request
	//  @return V0042OpenapiResp
	SlurmdbV0042PostClustersExecute(r SlurmdbAPISlurmdbV0042PostClustersRequest) (*V0042OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0042PostConfig Load all configuration information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042PostConfigRequest
	*/
	SlurmdbV0042PostConfig(ctx context.Context) SlurmdbAPISlurmdbV0042PostConfigRequest

	// SlurmdbV0042PostConfigExecute executes the request
	//  @return V0042OpenapiResp
	SlurmdbV0042PostConfigExecute(r SlurmdbAPISlurmdbV0042PostConfigRequest) (*V0042OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0042PostQos Add or update QOSs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042PostQosRequest
	*/
	SlurmdbV0042PostQos(ctx context.Context) SlurmdbAPISlurmdbV0042PostQosRequest

	// SlurmdbV0042PostQosExecute executes the request
	//  @return V0042OpenapiResp
	SlurmdbV0042PostQosExecute(r SlurmdbAPISlurmdbV0042PostQosRequest) (*V0042OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0042PostTres Add TRES

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042PostTresRequest
	*/
	SlurmdbV0042PostTres(ctx context.Context) SlurmdbAPISlurmdbV0042PostTresRequest

	// SlurmdbV0042PostTresExecute executes the request
	//  @return V0042OpenapiResp
	SlurmdbV0042PostTresExecute(r SlurmdbAPISlurmdbV0042PostTresRequest) (*V0042OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0042PostUsers Update users

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042PostUsersRequest
	*/
	SlurmdbV0042PostUsers(ctx context.Context) SlurmdbAPISlurmdbV0042PostUsersRequest

	// SlurmdbV0042PostUsersExecute executes the request
	//  @return V0042OpenapiResp
	SlurmdbV0042PostUsersExecute(r SlurmdbAPISlurmdbV0042PostUsersRequest) (*V0042OpenapiResp, *http.Response, error)

	/*
	SlurmdbV0042PostUsersAssociation Add users with conditional association

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042PostUsersAssociationRequest
	*/
	SlurmdbV0042PostUsersAssociation(ctx context.Context) SlurmdbAPISlurmdbV0042PostUsersAssociationRequest

	// SlurmdbV0042PostUsersAssociationExecute executes the request
	//  @return V0042OpenapiUsersAddCondRespStr
	SlurmdbV0042PostUsersAssociationExecute(r SlurmdbAPISlurmdbV0042PostUsersAssociationRequest) (*V0042OpenapiUsersAddCondRespStr, *http.Response, error)

	/*
	SlurmdbV0042PostWckeys Add or update wckeys

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return SlurmdbAPISlurmdbV0042PostWckeysRequest
	*/
	SlurmdbV0042PostWckeys(ctx context.Context) SlurmdbAPISlurmdbV0042PostWckeysRequest

	// SlurmdbV0042PostWckeysExecute executes the request
	//  @return V0042OpenapiResp
	SlurmdbV0042PostWckeysExecute(r SlurmdbAPISlurmdbV0042PostWckeysRequest) (*V0042OpenapiResp, *http.Response, error)
}

// SlurmdbAPIService SlurmdbAPI service
type SlurmdbAPIService service

type SlurmdbAPISlurmdbV0040DeleteAccountRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	accountName string
}

func (r SlurmdbAPISlurmdbV0040DeleteAccountRequest) Execute() (*V0040OpenapiAccountsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteAccountExecute(r)
}

/*
SlurmdbV0040DeleteAccount Delete account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName Account name
 @return SlurmdbAPISlurmdbV0040DeleteAccountRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAccount(ctx context.Context, accountName string) SlurmdbAPISlurmdbV0040DeleteAccountRequest {
	return SlurmdbAPISlurmdbV0040DeleteAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return V0040OpenapiAccountsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAccountExecute(r SlurmdbAPISlurmdbV0040DeleteAccountRequest) (*V0040OpenapiAccountsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAccountsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/account/{account_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_name"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAccountsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040DeleteAssociationRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) Account(account string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) DefaultQos(defaultQos string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.defaultQos = &defaultQos
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) Format(format string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.format = &format
	return r
}

// CSV id list
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) Id(id string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.id = &id
	return r
}

// Filter to only defaults
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) OnlyDefaults(onlyDefaults string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) ParentAccount(parentAccount string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) Partition(partition string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) Qos(qos string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) User(user string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.user = &user
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted associations
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include a raw qos or delta_qos
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) WithRawQos(withRawQos string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.withRawQos = &withRawQos
	return r
}

// Include sub acct information also
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) WithSubAccts(withSubAccts string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// Exclude parent id/name
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) WithoutParentInfo(withoutParentInfo string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// Exclude limits from parents
func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) WithoutParentLimits(withoutParentLimits string) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) Execute() (*V0040OpenapiAssocsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteAssociationExecute(r)
}

/*
SlurmdbV0040DeleteAssociation Delete association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040DeleteAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAssociation(ctx context.Context) SlurmdbAPISlurmdbV0040DeleteAssociationRequest {
	return SlurmdbAPISlurmdbV0040DeleteAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAssocsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAssociationExecute(r SlurmdbAPISlurmdbV0040DeleteAssociationRequest) (*V0040OpenapiAssocsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAssocsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "form", "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "form", "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "form", "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAssocsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040DeleteAssociationsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) Account(account string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) DefaultQos(defaultQos string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.defaultQos = &defaultQos
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) Format(format string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.format = &format
	return r
}

// CSV id list
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) Id(id string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.id = &id
	return r
}

// Filter to only defaults
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) OnlyDefaults(onlyDefaults string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) ParentAccount(parentAccount string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) Partition(partition string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) Qos(qos string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) User(user string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.user = &user
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted associations
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include a raw qos or delta_qos
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) WithRawQos(withRawQos string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.withRawQos = &withRawQos
	return r
}

// Include sub acct information also
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) WithSubAccts(withSubAccts string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// Exclude parent id/name
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) WithoutParentInfo(withoutParentInfo string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// Exclude limits from parents
func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) WithoutParentLimits(withoutParentLimits string) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) Execute() (*V0040OpenapiAssocsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteAssociationsExecute(r)
}

/*
SlurmdbV0040DeleteAssociations Delete associations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040DeleteAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAssociations(ctx context.Context) SlurmdbAPISlurmdbV0040DeleteAssociationsRequest {
	return SlurmdbAPISlurmdbV0040DeleteAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAssocsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteAssociationsExecute(r SlurmdbAPISlurmdbV0040DeleteAssociationsRequest) (*V0040OpenapiAssocsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAssocsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "form", "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "form", "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "form", "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAssocsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040DeleteClusterRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	clusterName string
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

// Type of machine
func (r SlurmdbAPISlurmdbV0040DeleteClusterRequest) Classification(classification string) SlurmdbAPISlurmdbV0040DeleteClusterRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r SlurmdbAPISlurmdbV0040DeleteClusterRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0040DeleteClusterRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r SlurmdbAPISlurmdbV0040DeleteClusterRequest) Federation(federation string) SlurmdbAPISlurmdbV0040DeleteClusterRequest {
	r.federation = &federation
	return r
}

// Query flags
func (r SlurmdbAPISlurmdbV0040DeleteClusterRequest) Flags(flags string) SlurmdbAPISlurmdbV0040DeleteClusterRequest {
	r.flags = &flags
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0040DeleteClusterRequest) Format(format string) SlurmdbAPISlurmdbV0040DeleteClusterRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r SlurmdbAPISlurmdbV0040DeleteClusterRequest) RpcVersion(rpcVersion string) SlurmdbAPISlurmdbV0040DeleteClusterRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040DeleteClusterRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0040DeleteClusterRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040DeleteClusterRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0040DeleteClusterRequest {
	r.usageStart = &usageStart
	return r
}

// Include deleted clusters
func (r SlurmdbAPISlurmdbV0040DeleteClusterRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040DeleteClusterRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0040DeleteClusterRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0040DeleteClusterRequest {
	r.withUsage = &withUsage
	return r
}

func (r SlurmdbAPISlurmdbV0040DeleteClusterRequest) Execute() (*V0040OpenapiClustersRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteClusterExecute(r)
}

/*
SlurmdbV0040DeleteCluster Delete cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName Cluster name
 @return SlurmdbAPISlurmdbV0040DeleteClusterRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteCluster(ctx context.Context, clusterName string) SlurmdbAPISlurmdbV0040DeleteClusterRequest {
	return SlurmdbAPISlurmdbV0040DeleteClusterRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return V0040OpenapiClustersRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteClusterExecute(r SlurmdbAPISlurmdbV0040DeleteClusterRequest) (*V0040OpenapiClustersRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiClustersRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/cluster/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "form", "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiClustersRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040DeleteSingleQosRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	qos string
}

func (r SlurmdbAPISlurmdbV0040DeleteSingleQosRequest) Execute() (*V0040OpenapiSlurmdbdQosRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteSingleQosExecute(r)
}

/*
SlurmdbV0040DeleteSingleQos Delete QOS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param qos QOS name
 @return SlurmdbAPISlurmdbV0040DeleteSingleQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteSingleQos(ctx context.Context, qos string) SlurmdbAPISlurmdbV0040DeleteSingleQosRequest {
	return SlurmdbAPISlurmdbV0040DeleteSingleQosRequest{
		ApiService: a,
		ctx: ctx,
		qos: qos,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdQosRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteSingleQosExecute(r SlurmdbAPISlurmdbV0040DeleteSingleQosRequest) (*V0040OpenapiSlurmdbdQosRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdQosRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteSingleQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/qos/{qos}"
	localVarPath = strings.Replace(localVarPath, "{"+"qos"+"}", url.PathEscape(parameterValueToString(r.qos, "qos")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdQosRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040DeleteUserRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	name string
}

func (r SlurmdbAPISlurmdbV0040DeleteUserRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteUserExecute(r)
}

/*
SlurmdbV0040DeleteUser Delete user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name User name
 @return SlurmdbAPISlurmdbV0040DeleteUserRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteUser(ctx context.Context, name string) SlurmdbAPISlurmdbV0040DeleteUserRequest {
	return SlurmdbAPISlurmdbV0040DeleteUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteUserExecute(r SlurmdbAPISlurmdbV0040DeleteUserRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/user/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040DeleteWckeyRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	id string
}

func (r SlurmdbAPISlurmdbV0040DeleteWckeyRequest) Execute() (*V0040OpenapiWckeyRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040DeleteWckeyExecute(r)
}

/*
SlurmdbV0040DeleteWckey Delete wckey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id wckey id
 @return SlurmdbAPISlurmdbV0040DeleteWckeyRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040DeleteWckey(ctx context.Context, id string) SlurmdbAPISlurmdbV0040DeleteWckeyRequest {
	return SlurmdbAPISlurmdbV0040DeleteWckeyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V0040OpenapiWckeyRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0040DeleteWckeyExecute(r SlurmdbAPISlurmdbV0040DeleteWckeyRequest) (*V0040OpenapiWckeyRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiWckeyRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040DeleteWckey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/wckey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiWckeyRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetAccountRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	accountName string
	withAssocs *string
	withCoords *string
	withDeleted *string
}

// Include associations
func (r SlurmdbAPISlurmdbV0040GetAccountRequest) WithAssocs(withAssocs string) SlurmdbAPISlurmdbV0040GetAccountRequest {
	r.withAssocs = &withAssocs
	return r
}

// Include coordinators
func (r SlurmdbAPISlurmdbV0040GetAccountRequest) WithCoords(withCoords string) SlurmdbAPISlurmdbV0040GetAccountRequest {
	r.withCoords = &withCoords
	return r
}

// Include deleted
func (r SlurmdbAPISlurmdbV0040GetAccountRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040GetAccountRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r SlurmdbAPISlurmdbV0040GetAccountRequest) Execute() (*V0040OpenapiAccountsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetAccountExecute(r)
}

/*
SlurmdbV0040GetAccount Get account info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName Account name
 @return SlurmdbAPISlurmdbV0040GetAccountRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetAccount(ctx context.Context, accountName string) SlurmdbAPISlurmdbV0040GetAccountRequest {
	return SlurmdbAPISlurmdbV0040GetAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return V0040OpenapiAccountsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetAccountExecute(r SlurmdbAPISlurmdbV0040GetAccountRequest) (*V0040OpenapiAccountsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAccountsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/account/{account_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_name"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "form", "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAccountsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetAccountsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	description *string
	withAssocs *string
	withCoords *string
	withDeleted *string
}

// CSV description list
func (r SlurmdbAPISlurmdbV0040GetAccountsRequest) Description(description string) SlurmdbAPISlurmdbV0040GetAccountsRequest {
	r.description = &description
	return r
}

// Include associations
func (r SlurmdbAPISlurmdbV0040GetAccountsRequest) WithAssocs(withAssocs string) SlurmdbAPISlurmdbV0040GetAccountsRequest {
	r.withAssocs = &withAssocs
	return r
}

// Include coordinators
func (r SlurmdbAPISlurmdbV0040GetAccountsRequest) WithCoords(withCoords string) SlurmdbAPISlurmdbV0040GetAccountsRequest {
	r.withCoords = &withCoords
	return r
}

// Include deleted accounts
func (r SlurmdbAPISlurmdbV0040GetAccountsRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040GetAccountsRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r SlurmdbAPISlurmdbV0040GetAccountsRequest) Execute() (*V0040OpenapiAccountsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetAccountsExecute(r)
}

/*
SlurmdbV0040GetAccounts Get account list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040GetAccountsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetAccounts(ctx context.Context) SlurmdbAPISlurmdbV0040GetAccountsRequest {
	return SlurmdbAPISlurmdbV0040GetAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAccountsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetAccountsExecute(r SlurmdbAPISlurmdbV0040GetAccountsRequest) (*V0040OpenapiAccountsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAccountsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/accounts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "form", "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAccountsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetAssociationRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) Account(account string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) DefaultQos(defaultQos string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.defaultQos = &defaultQos
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) Format(format string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.format = &format
	return r
}

// CSV id list
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) Id(id string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.id = &id
	return r
}

// Filter to only defaults
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) OnlyDefaults(onlyDefaults string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) ParentAccount(parentAccount string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) Partition(partition string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) Qos(qos string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) User(user string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.user = &user
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted associations
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include a raw qos or delta_qos
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) WithRawQos(withRawQos string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.withRawQos = &withRawQos
	return r
}

// Include sub acct information also
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) WithSubAccts(withSubAccts string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// Exclude parent id/name
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) WithoutParentInfo(withoutParentInfo string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// Exclude limits from parents
func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) WithoutParentLimits(withoutParentLimits string) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r SlurmdbAPISlurmdbV0040GetAssociationRequest) Execute() (*V0040OpenapiAssocsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetAssociationExecute(r)
}

/*
SlurmdbV0040GetAssociation Get association info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040GetAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetAssociation(ctx context.Context) SlurmdbAPISlurmdbV0040GetAssociationRequest {
	return SlurmdbAPISlurmdbV0040GetAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAssocsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetAssociationExecute(r SlurmdbAPISlurmdbV0040GetAssociationRequest) (*V0040OpenapiAssocsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAssocsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "form", "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "form", "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "form", "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAssocsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetAssociationsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) Account(account string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) DefaultQos(defaultQos string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.defaultQos = &defaultQos
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) Format(format string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.format = &format
	return r
}

// CSV id list
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) Id(id string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.id = &id
	return r
}

// Filter to only defaults
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) OnlyDefaults(onlyDefaults string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) ParentAccount(parentAccount string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) Partition(partition string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) Qos(qos string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) User(user string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.user = &user
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted associations
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include a raw qos or delta_qos
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) WithRawQos(withRawQos string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.withRawQos = &withRawQos
	return r
}

// Include sub acct information also
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) WithSubAccts(withSubAccts string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// Exclude parent id/name
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) WithoutParentInfo(withoutParentInfo string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// Exclude limits from parents
func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) WithoutParentLimits(withoutParentLimits string) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r SlurmdbAPISlurmdbV0040GetAssociationsRequest) Execute() (*V0040OpenapiAssocsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetAssociationsExecute(r)
}

/*
SlurmdbV0040GetAssociations Get association list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040GetAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetAssociations(ctx context.Context) SlurmdbAPISlurmdbV0040GetAssociationsRequest {
	return SlurmdbAPISlurmdbV0040GetAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAssocsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetAssociationsExecute(r SlurmdbAPISlurmdbV0040GetAssociationsRequest) (*V0040OpenapiAssocsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAssocsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "form", "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "form", "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "form", "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAssocsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetClusterRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	clusterName string
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

// Type of machine
func (r SlurmdbAPISlurmdbV0040GetClusterRequest) Classification(classification string) SlurmdbAPISlurmdbV0040GetClusterRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r SlurmdbAPISlurmdbV0040GetClusterRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0040GetClusterRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r SlurmdbAPISlurmdbV0040GetClusterRequest) Federation(federation string) SlurmdbAPISlurmdbV0040GetClusterRequest {
	r.federation = &federation
	return r
}

// Query flags
func (r SlurmdbAPISlurmdbV0040GetClusterRequest) Flags(flags string) SlurmdbAPISlurmdbV0040GetClusterRequest {
	r.flags = &flags
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0040GetClusterRequest) Format(format string) SlurmdbAPISlurmdbV0040GetClusterRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r SlurmdbAPISlurmdbV0040GetClusterRequest) RpcVersion(rpcVersion string) SlurmdbAPISlurmdbV0040GetClusterRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetClusterRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0040GetClusterRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetClusterRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0040GetClusterRequest {
	r.usageStart = &usageStart
	return r
}

// Include deleted clusters
func (r SlurmdbAPISlurmdbV0040GetClusterRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040GetClusterRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0040GetClusterRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0040GetClusterRequest {
	r.withUsage = &withUsage
	return r
}

func (r SlurmdbAPISlurmdbV0040GetClusterRequest) Execute() (*V0040OpenapiClustersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetClusterExecute(r)
}

/*
SlurmdbV0040GetCluster Get cluster info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName Cluster name
 @return SlurmdbAPISlurmdbV0040GetClusterRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetCluster(ctx context.Context, clusterName string) SlurmdbAPISlurmdbV0040GetClusterRequest {
	return SlurmdbAPISlurmdbV0040GetClusterRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return V0040OpenapiClustersResp
func (a *SlurmdbAPIService) SlurmdbV0040GetClusterExecute(r SlurmdbAPISlurmdbV0040GetClusterRequest) (*V0040OpenapiClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/cluster/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "form", "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiClustersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetClustersRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	updateTime *string
}

// Filter reservations since update timestamp
func (r SlurmdbAPISlurmdbV0040GetClustersRequest) UpdateTime(updateTime string) SlurmdbAPISlurmdbV0040GetClustersRequest {
	r.updateTime = &updateTime
	return r
}

func (r SlurmdbAPISlurmdbV0040GetClustersRequest) Execute() (*V0040OpenapiClustersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetClustersExecute(r)
}

/*
SlurmdbV0040GetClusters Get cluster list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040GetClustersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetClusters(ctx context.Context) SlurmdbAPISlurmdbV0040GetClustersRequest {
	return SlurmdbAPISlurmdbV0040GetClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiClustersResp
func (a *SlurmdbAPIService) SlurmdbV0040GetClustersExecute(r SlurmdbAPISlurmdbV0040GetClustersRequest) (*V0040OpenapiClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiClustersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetConfigRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
}

func (r SlurmdbAPISlurmdbV0040GetConfigRequest) Execute() (*V0040OpenapiSlurmdbdConfigResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetConfigExecute(r)
}

/*
SlurmdbV0040GetConfig Dump all configuration information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040GetConfigRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetConfig(ctx context.Context) SlurmdbAPISlurmdbV0040GetConfigRequest {
	return SlurmdbAPISlurmdbV0040GetConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdConfigResp
func (a *SlurmdbAPIService) SlurmdbV0040GetConfigExecute(r SlurmdbAPISlurmdbV0040GetConfigRequest) (*V0040OpenapiSlurmdbdConfigResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdConfigResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdConfigResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetDiagRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
}

func (r SlurmdbAPISlurmdbV0040GetDiagRequest) Execute() (*V0040OpenapiSlurmdbdStatsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetDiagExecute(r)
}

/*
SlurmdbV0040GetDiag Get slurmdb diagnostics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040GetDiagRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetDiag(ctx context.Context) SlurmdbAPISlurmdbV0040GetDiagRequest {
	return SlurmdbAPISlurmdbV0040GetDiagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdStatsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetDiagExecute(r SlurmdbAPISlurmdbV0040GetDiagRequest) (*V0040OpenapiSlurmdbdStatsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdStatsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetDiag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/diag/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdStatsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetInstanceRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	cluster *string
	extra *string
	format *string
	instanceId *string
	instanceType *string
	nodeList *string
	timeEnd *string
	timeStart *string
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0040GetInstanceRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0040GetInstanceRequest {
	r.cluster = &cluster
	return r
}

// CSV extra list
func (r SlurmdbAPISlurmdbV0040GetInstanceRequest) Extra(extra string) SlurmdbAPISlurmdbV0040GetInstanceRequest {
	r.extra = &extra
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0040GetInstanceRequest) Format(format string) SlurmdbAPISlurmdbV0040GetInstanceRequest {
	r.format = &format
	return r
}

// CSV instance_id list
func (r SlurmdbAPISlurmdbV0040GetInstanceRequest) InstanceId(instanceId string) SlurmdbAPISlurmdbV0040GetInstanceRequest {
	r.instanceId = &instanceId
	return r
}

// CSV instance_type list
func (r SlurmdbAPISlurmdbV0040GetInstanceRequest) InstanceType(instanceType string) SlurmdbAPISlurmdbV0040GetInstanceRequest {
	r.instanceType = &instanceType
	return r
}

// Ranged node string
func (r SlurmdbAPISlurmdbV0040GetInstanceRequest) NodeList(nodeList string) SlurmdbAPISlurmdbV0040GetInstanceRequest {
	r.nodeList = &nodeList
	return r
}

// Time end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetInstanceRequest) TimeEnd(timeEnd string) SlurmdbAPISlurmdbV0040GetInstanceRequest {
	r.timeEnd = &timeEnd
	return r
}

// Time start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetInstanceRequest) TimeStart(timeStart string) SlurmdbAPISlurmdbV0040GetInstanceRequest {
	r.timeStart = &timeStart
	return r
}

func (r SlurmdbAPISlurmdbV0040GetInstanceRequest) Execute() (*V0040OpenapiInstancesResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetInstanceExecute(r)
}

/*
SlurmdbV0040GetInstance Get instance info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040GetInstanceRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetInstance(ctx context.Context) SlurmdbAPISlurmdbV0040GetInstanceRequest {
	return SlurmdbAPISlurmdbV0040GetInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiInstancesResp
func (a *SlurmdbAPIService) SlurmdbV0040GetInstanceExecute(r SlurmdbAPISlurmdbV0040GetInstanceRequest) (*V0040OpenapiInstancesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiInstancesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/instance/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.extra != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extra", r.extra, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "form", "")
	}
	if r.instanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_type", r.instanceType, "form", "")
	}
	if r.nodeList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_list", r.nodeList, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiInstancesResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetInstancesRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	cluster *string
	extra *string
	format *string
	instanceId *string
	instanceType *string
	nodeList *string
	timeEnd *string
	timeStart *string
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0040GetInstancesRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0040GetInstancesRequest {
	r.cluster = &cluster
	return r
}

// CSV extra list
func (r SlurmdbAPISlurmdbV0040GetInstancesRequest) Extra(extra string) SlurmdbAPISlurmdbV0040GetInstancesRequest {
	r.extra = &extra
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0040GetInstancesRequest) Format(format string) SlurmdbAPISlurmdbV0040GetInstancesRequest {
	r.format = &format
	return r
}

// CSV instance_id list
func (r SlurmdbAPISlurmdbV0040GetInstancesRequest) InstanceId(instanceId string) SlurmdbAPISlurmdbV0040GetInstancesRequest {
	r.instanceId = &instanceId
	return r
}

// CSV instance_type list
func (r SlurmdbAPISlurmdbV0040GetInstancesRequest) InstanceType(instanceType string) SlurmdbAPISlurmdbV0040GetInstancesRequest {
	r.instanceType = &instanceType
	return r
}

// Ranged node string
func (r SlurmdbAPISlurmdbV0040GetInstancesRequest) NodeList(nodeList string) SlurmdbAPISlurmdbV0040GetInstancesRequest {
	r.nodeList = &nodeList
	return r
}

// Time end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetInstancesRequest) TimeEnd(timeEnd string) SlurmdbAPISlurmdbV0040GetInstancesRequest {
	r.timeEnd = &timeEnd
	return r
}

// Time start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetInstancesRequest) TimeStart(timeStart string) SlurmdbAPISlurmdbV0040GetInstancesRequest {
	r.timeStart = &timeStart
	return r
}

func (r SlurmdbAPISlurmdbV0040GetInstancesRequest) Execute() (*V0040OpenapiInstancesResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetInstancesExecute(r)
}

/*
SlurmdbV0040GetInstances Get instance list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040GetInstancesRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetInstances(ctx context.Context) SlurmdbAPISlurmdbV0040GetInstancesRequest {
	return SlurmdbAPISlurmdbV0040GetInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiInstancesResp
func (a *SlurmdbAPIService) SlurmdbV0040GetInstancesExecute(r SlurmdbAPISlurmdbV0040GetInstancesRequest) (*V0040OpenapiInstancesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiInstancesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/instances/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.extra != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extra", r.extra, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "form", "")
	}
	if r.instanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_type", r.instanceType, "form", "")
	}
	if r.nodeList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_list", r.nodeList, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiInstancesResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetJobRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	jobId string
}

func (r SlurmdbAPISlurmdbV0040GetJobRequest) Execute() (*V0040OpenapiSlurmdbdJobsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetJobExecute(r)
}

/*
SlurmdbV0040GetJob Get job info

This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId Job id
 @return SlurmdbAPISlurmdbV0040GetJobRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetJob(ctx context.Context, jobId string) SlurmdbAPISlurmdbV0040GetJobRequest {
	return SlurmdbAPISlurmdbV0040GetJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdJobsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetJobExecute(r SlurmdbAPISlurmdbV0040GetJobRequest) (*V0040OpenapiSlurmdbdJobsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdJobsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/job/{job_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdJobsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetJobsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	association *string
	cluster *string
	constraints *string
	cpusMax *string
	cpusMin *string
	schedulerUnset *string
	scheduledOnSubmit *string
	scheduledByMain *string
	scheduledByBackfill *string
	jobStarted *string
	exitCode *string
	showDuplicates *string
	skipSteps *string
	disableTruncateUsageTime *string
	wholeHetjob *string
	disableWholeHetjob *string
	disableWaitForResult *string
	usageTimeAsSubmitTime *string
	showBatchScript *string
	showJobEnvironment *string
	format *string
	groups *string
	jobName *string
	nodesMax *string
	nodesMin *string
	partition *string
	qos *string
	reason *string
	reservation *string
	reservationId *string
	state *string
	step *string
	timelimitMax *string
	timelimitMin *string
	endTime *string
	startTime *string
	submitTime *string
	node *string
	users *string
	wckey *string
}

// CSV account list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Account(account string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.account = &account
	return r
}

// CSV association list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Association(association string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.association = &association
	return r
}

// CSV cluster list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.cluster = &cluster
	return r
}

// CSV constraint list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Constraints(constraints string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.constraints = &constraints
	return r
}

// Maximum number of cpus
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) CpusMax(cpusMax string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.cpusMax = &cpusMax
	return r
}

// Minimum number of cpus
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) CpusMin(cpusMin string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.cpusMin = &cpusMin
	return r
}

// Schedule bits not set
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) SchedulerUnset(schedulerUnset string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.schedulerUnset = &schedulerUnset
	return r
}

// Job was started on submit
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) ScheduledOnSubmit(scheduledOnSubmit string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.scheduledOnSubmit = &scheduledOnSubmit
	return r
}

// Job was started from main scheduler
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) ScheduledByMain(scheduledByMain string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.scheduledByMain = &scheduledByMain
	return r
}

// Job was started from backfill
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) ScheduledByBackfill(scheduledByBackfill string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.scheduledByBackfill = &scheduledByBackfill
	return r
}

// Job start RPC was received
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) JobStarted(jobStarted string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.jobStarted = &jobStarted
	return r
}

// Job exit code (numeric)
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) ExitCode(exitCode string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.exitCode = &exitCode
	return r
}

// Include duplicate job entries
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) ShowDuplicates(showDuplicates string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.showDuplicates = &showDuplicates
	return r
}

// Exclude job step details
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) SkipSteps(skipSteps string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.skipSteps = &skipSteps
	return r
}

// Do not truncate the time to usage_start and usage_end
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) DisableTruncateUsageTime(disableTruncateUsageTime string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.disableTruncateUsageTime = &disableTruncateUsageTime
	return r
}

// Include details on all hetjob components
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) WholeHetjob(wholeHetjob string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.wholeHetjob = &wholeHetjob
	return r
}

// Only show details on specified hetjob components
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) DisableWholeHetjob(disableWholeHetjob string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.disableWholeHetjob = &disableWholeHetjob
	return r
}

// Tell dbd not to wait for the result
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) DisableWaitForResult(disableWaitForResult string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.disableWaitForResult = &disableWaitForResult
	return r
}

// Use usage_time as the submit_time of the job
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) UsageTimeAsSubmitTime(usageTimeAsSubmitTime string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.usageTimeAsSubmitTime = &usageTimeAsSubmitTime
	return r
}

// Include job script
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) ShowBatchScript(showBatchScript string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.showBatchScript = &showBatchScript
	return r
}

// Include job environment
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) ShowJobEnvironment(showJobEnvironment string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.showJobEnvironment = &showJobEnvironment
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Format(format string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.format = &format
	return r
}

// CSV group list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Groups(groups string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.groups = &groups
	return r
}

// CSV job name list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) JobName(jobName string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.jobName = &jobName
	return r
}

// Maximum number of nodes
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) NodesMax(nodesMax string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.nodesMax = &nodesMax
	return r
}

// Minimum number of nodes
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) NodesMin(nodesMin string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.nodesMin = &nodesMin
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Partition(partition string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.partition = &partition
	return r
}

// CSV QOS name list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Qos(qos string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.qos = &qos
	return r
}

// CSV reason list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Reason(reason string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.reason = &reason
	return r
}

// CSV reservation name list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Reservation(reservation string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.reservation = &reservation
	return r
}

// CSV reservation ID list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) ReservationId(reservationId string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.reservationId = &reservationId
	return r
}

// CSV state list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) State(state string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.state = &state
	return r
}

// CSV step id list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Step(step string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.step = &step
	return r
}

// Maximum timelimit (seconds)
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) TimelimitMax(timelimitMax string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.timelimitMax = &timelimitMax
	return r
}

// Minimum timelimit (seconds)
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) TimelimitMin(timelimitMin string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.timelimitMin = &timelimitMin
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) EndTime(endTime string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.endTime = &endTime
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) StartTime(startTime string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.startTime = &startTime
	return r
}

// Submit time (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) SubmitTime(submitTime string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.submitTime = &submitTime
	return r
}

// Ranged node string where jobs ran
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Node(node string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.node = &node
	return r
}

// CSV user name list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Users(users string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.users = &users
	return r
}

// CSV wckey list
func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Wckey(wckey string) SlurmdbAPISlurmdbV0040GetJobsRequest {
	r.wckey = &wckey
	return r
}

func (r SlurmdbAPISlurmdbV0040GetJobsRequest) Execute() (*V0040OpenapiSlurmdbdJobsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetJobsExecute(r)
}

/*
SlurmdbV0040GetJobs Get job list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040GetJobsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetJobs(ctx context.Context) SlurmdbAPISlurmdbV0040GetJobsRequest {
	return SlurmdbAPISlurmdbV0040GetJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdJobsResp
func (a *SlurmdbAPIService) SlurmdbV0040GetJobsExecute(r SlurmdbAPISlurmdbV0040GetJobsRequest) (*V0040OpenapiSlurmdbdJobsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdJobsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.association != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "association", r.association, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.constraints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "constraints", r.constraints, "form", "")
	}
	if r.cpusMax != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpus_max", r.cpusMax, "form", "")
	}
	if r.cpusMin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpus_min", r.cpusMin, "form", "")
	}
	if r.schedulerUnset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduler_unset", r.schedulerUnset, "form", "")
	}
	if r.scheduledOnSubmit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_on_submit", r.scheduledOnSubmit, "form", "")
	}
	if r.scheduledByMain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_by_main", r.scheduledByMain, "form", "")
	}
	if r.scheduledByBackfill != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_by_backfill", r.scheduledByBackfill, "form", "")
	}
	if r.jobStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_started", r.jobStarted, "form", "")
	}
	if r.exitCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exit_code", r.exitCode, "form", "")
	}
	if r.showDuplicates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_duplicates", r.showDuplicates, "form", "")
	}
	if r.skipSteps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_steps", r.skipSteps, "form", "")
	}
	if r.disableTruncateUsageTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_truncate_usage_time", r.disableTruncateUsageTime, "form", "")
	}
	if r.wholeHetjob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "whole_hetjob", r.wholeHetjob, "form", "")
	}
	if r.disableWholeHetjob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_whole_hetjob", r.disableWholeHetjob, "form", "")
	}
	if r.disableWaitForResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_wait_for_result", r.disableWaitForResult, "form", "")
	}
	if r.usageTimeAsSubmitTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_time_as_submit_time", r.usageTimeAsSubmitTime, "form", "")
	}
	if r.showBatchScript != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_batch_script", r.showBatchScript, "form", "")
	}
	if r.showJobEnvironment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_job_environment", r.showJobEnvironment, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.groups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groups", r.groups, "form", "")
	}
	if r.jobName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_name", r.jobName, "form", "")
	}
	if r.nodesMax != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_max", r.nodesMax, "form", "")
	}
	if r.nodesMin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nodes_min", r.nodesMin, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.reason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reason", r.reason, "form", "")
	}
	if r.reservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservation", r.reservation, "form", "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservation_id", r.reservationId, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.step != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "step", r.step, "form", "")
	}
	if r.timelimitMax != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timelimit_max", r.timelimitMax, "form", "")
	}
	if r.timelimitMin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timelimit_min", r.timelimitMin, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	}
	if r.submitTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "submit_time", r.submitTime, "form", "")
	}
	if r.node != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node", r.node, "form", "")
	}
	if r.users != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "users", r.users, "form", "")
	}
	if r.wckey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wckey", r.wckey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdJobsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetQosRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	description *string
	id *string
	format *string
	name *string
	preemptMode *string
	withDeleted *string
}

// CSV description list
func (r SlurmdbAPISlurmdbV0040GetQosRequest) Description(description string) SlurmdbAPISlurmdbV0040GetQosRequest {
	r.description = &description
	return r
}

// CSV QOS id list
func (r SlurmdbAPISlurmdbV0040GetQosRequest) Id(id string) SlurmdbAPISlurmdbV0040GetQosRequest {
	r.id = &id
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0040GetQosRequest) Format(format string) SlurmdbAPISlurmdbV0040GetQosRequest {
	r.format = &format
	return r
}

// CSV QOS name list
func (r SlurmdbAPISlurmdbV0040GetQosRequest) Name(name string) SlurmdbAPISlurmdbV0040GetQosRequest {
	r.name = &name
	return r
}

// PreemptMode used when jobs in this QOS are preempted
func (r SlurmdbAPISlurmdbV0040GetQosRequest) PreemptMode(preemptMode string) SlurmdbAPISlurmdbV0040GetQosRequest {
	r.preemptMode = &preemptMode
	return r
}

// Include deleted QOS
func (r SlurmdbAPISlurmdbV0040GetQosRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040GetQosRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r SlurmdbAPISlurmdbV0040GetQosRequest) Execute() (*V0040OpenapiSlurmdbdQosResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetQosExecute(r)
}

/*
SlurmdbV0040GetQos Get QOS list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040GetQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetQos(ctx context.Context) SlurmdbAPISlurmdbV0040GetQosRequest {
	return SlurmdbAPISlurmdbV0040GetQosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdQosResp
func (a *SlurmdbAPIService) SlurmdbV0040GetQosExecute(r SlurmdbAPISlurmdbV0040GetQosRequest) (*V0040OpenapiSlurmdbdQosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdQosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/qos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.preemptMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preempt_mode", r.preemptMode, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdQosResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetSingleQosRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	qos string
	withDeleted *string
}

// Query includes deleted QOS
func (r SlurmdbAPISlurmdbV0040GetSingleQosRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040GetSingleQosRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r SlurmdbAPISlurmdbV0040GetSingleQosRequest) Execute() (*V0040OpenapiSlurmdbdQosResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetSingleQosExecute(r)
}

/*
SlurmdbV0040GetSingleQos Get QOS info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param qos QOS name
 @return SlurmdbAPISlurmdbV0040GetSingleQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetSingleQos(ctx context.Context, qos string) SlurmdbAPISlurmdbV0040GetSingleQosRequest {
	return SlurmdbAPISlurmdbV0040GetSingleQosRequest{
		ApiService: a,
		ctx: ctx,
		qos: qos,
	}
}

// Execute executes the request
//  @return V0040OpenapiSlurmdbdQosResp
func (a *SlurmdbAPIService) SlurmdbV0040GetSingleQosExecute(r SlurmdbAPISlurmdbV0040GetSingleQosRequest) (*V0040OpenapiSlurmdbdQosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiSlurmdbdQosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetSingleQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/qos/{qos}"
	localVarPath = strings.Replace(localVarPath, "{"+"qos"+"}", url.PathEscape(parameterValueToString(r.qos, "qos")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiSlurmdbdQosResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetTresRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
}

func (r SlurmdbAPISlurmdbV0040GetTresRequest) Execute() (*V0040OpenapiTresResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetTresExecute(r)
}

/*
SlurmdbV0040GetTres Get TRES info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040GetTresRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetTres(ctx context.Context) SlurmdbAPISlurmdbV0040GetTresRequest {
	return SlurmdbAPISlurmdbV0040GetTresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiTresResp
func (a *SlurmdbAPIService) SlurmdbV0040GetTresExecute(r SlurmdbAPISlurmdbV0040GetTresRequest) (*V0040OpenapiTresResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiTresResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetTres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/tres/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiTresResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetUserRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	name string
	withDeleted *string
	withAssocs *string
	withCoords *string
	withWckeys *string
}

// Include deleted users
func (r SlurmdbAPISlurmdbV0040GetUserRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040GetUserRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include associations
func (r SlurmdbAPISlurmdbV0040GetUserRequest) WithAssocs(withAssocs string) SlurmdbAPISlurmdbV0040GetUserRequest {
	r.withAssocs = &withAssocs
	return r
}

// Include coordinators
func (r SlurmdbAPISlurmdbV0040GetUserRequest) WithCoords(withCoords string) SlurmdbAPISlurmdbV0040GetUserRequest {
	r.withCoords = &withCoords
	return r
}

// Include wckeys
func (r SlurmdbAPISlurmdbV0040GetUserRequest) WithWckeys(withWckeys string) SlurmdbAPISlurmdbV0040GetUserRequest {
	r.withWckeys = &withWckeys
	return r
}

func (r SlurmdbAPISlurmdbV0040GetUserRequest) Execute() (*V0040OpenapiUsersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetUserExecute(r)
}

/*
SlurmdbV0040GetUser Get user info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name User name
 @return SlurmdbAPISlurmdbV0040GetUserRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetUser(ctx context.Context, name string) SlurmdbAPISlurmdbV0040GetUserRequest {
	return SlurmdbAPISlurmdbV0040GetUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V0040OpenapiUsersResp
func (a *SlurmdbAPIService) SlurmdbV0040GetUserExecute(r SlurmdbAPISlurmdbV0040GetUserRequest) (*V0040OpenapiUsersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiUsersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/user/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "form", "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "form", "")
	}
	if r.withWckeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_wckeys", r.withWckeys, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiUsersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetUsersRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	adminLevel *string
	defaultAccount *string
	defaultWckey *string
	withAssocs *string
	withCoords *string
	withDeleted *string
	withWckeys *string
	withoutDefaults *string
}

// Administrator level
func (r SlurmdbAPISlurmdbV0040GetUsersRequest) AdminLevel(adminLevel string) SlurmdbAPISlurmdbV0040GetUsersRequest {
	r.adminLevel = &adminLevel
	return r
}

// CSV default account list
func (r SlurmdbAPISlurmdbV0040GetUsersRequest) DefaultAccount(defaultAccount string) SlurmdbAPISlurmdbV0040GetUsersRequest {
	r.defaultAccount = &defaultAccount
	return r
}

// CSV default wckey list
func (r SlurmdbAPISlurmdbV0040GetUsersRequest) DefaultWckey(defaultWckey string) SlurmdbAPISlurmdbV0040GetUsersRequest {
	r.defaultWckey = &defaultWckey
	return r
}

// With associations
func (r SlurmdbAPISlurmdbV0040GetUsersRequest) WithAssocs(withAssocs string) SlurmdbAPISlurmdbV0040GetUsersRequest {
	r.withAssocs = &withAssocs
	return r
}

// With coordinators
func (r SlurmdbAPISlurmdbV0040GetUsersRequest) WithCoords(withCoords string) SlurmdbAPISlurmdbV0040GetUsersRequest {
	r.withCoords = &withCoords
	return r
}

// With deleted
func (r SlurmdbAPISlurmdbV0040GetUsersRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040GetUsersRequest {
	r.withDeleted = &withDeleted
	return r
}

// With wckeys
func (r SlurmdbAPISlurmdbV0040GetUsersRequest) WithWckeys(withWckeys string) SlurmdbAPISlurmdbV0040GetUsersRequest {
	r.withWckeys = &withWckeys
	return r
}

// Exclude defaults
func (r SlurmdbAPISlurmdbV0040GetUsersRequest) WithoutDefaults(withoutDefaults string) SlurmdbAPISlurmdbV0040GetUsersRequest {
	r.withoutDefaults = &withoutDefaults
	return r
}

func (r SlurmdbAPISlurmdbV0040GetUsersRequest) Execute() (*V0040OpenapiUsersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetUsersExecute(r)
}

/*
SlurmdbV0040GetUsers Get user list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040GetUsersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetUsers(ctx context.Context) SlurmdbAPISlurmdbV0040GetUsersRequest {
	return SlurmdbAPISlurmdbV0040GetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiUsersResp
func (a *SlurmdbAPIService) SlurmdbV0040GetUsersExecute(r SlurmdbAPISlurmdbV0040GetUsersRequest) (*V0040OpenapiUsersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiUsersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.adminLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "admin_level", r.adminLevel, "form", "")
	}
	if r.defaultAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_account", r.defaultAccount, "form", "")
	}
	if r.defaultWckey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_wckey", r.defaultWckey, "form", "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "form", "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withWckeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_wckeys", r.withWckeys, "form", "")
	}
	if r.withoutDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_defaults", r.withoutDefaults, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiUsersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetWckeyRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	id string
}

func (r SlurmdbAPISlurmdbV0040GetWckeyRequest) Execute() (*V0040OpenapiWckeyResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetWckeyExecute(r)
}

/*
SlurmdbV0040GetWckey Get wckey info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id wckey id
 @return SlurmdbAPISlurmdbV0040GetWckeyRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetWckey(ctx context.Context, id string) SlurmdbAPISlurmdbV0040GetWckeyRequest {
	return SlurmdbAPISlurmdbV0040GetWckeyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V0040OpenapiWckeyResp
func (a *SlurmdbAPIService) SlurmdbV0040GetWckeyExecute(r SlurmdbAPISlurmdbV0040GetWckeyRequest) (*V0040OpenapiWckeyResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiWckeyResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetWckey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/wckey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiWckeyResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040GetWckeysRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	cluster *string
	format *string
	id *string
	name *string
	onlyDefaults *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
}

// CSV cluster name list
func (r SlurmdbAPISlurmdbV0040GetWckeysRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0040GetWckeysRequest {
	r.cluster = &cluster
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0040GetWckeysRequest) Format(format string) SlurmdbAPISlurmdbV0040GetWckeysRequest {
	r.format = &format
	return r
}

// CSV id list
func (r SlurmdbAPISlurmdbV0040GetWckeysRequest) Id(id string) SlurmdbAPISlurmdbV0040GetWckeysRequest {
	r.id = &id
	return r
}

// CSV name list
func (r SlurmdbAPISlurmdbV0040GetWckeysRequest) Name(name string) SlurmdbAPISlurmdbV0040GetWckeysRequest {
	r.name = &name
	return r
}

// Only query defaults
func (r SlurmdbAPISlurmdbV0040GetWckeysRequest) OnlyDefaults(onlyDefaults string) SlurmdbAPISlurmdbV0040GetWckeysRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetWckeysRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0040GetWckeysRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040GetWckeysRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0040GetWckeysRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0040GetWckeysRequest) User(user string) SlurmdbAPISlurmdbV0040GetWckeysRequest {
	r.user = &user
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0040GetWckeysRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0040GetWckeysRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted wckeys
func (r SlurmdbAPISlurmdbV0040GetWckeysRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040GetWckeysRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r SlurmdbAPISlurmdbV0040GetWckeysRequest) Execute() (*V0040OpenapiWckeyResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040GetWckeysExecute(r)
}

/*
SlurmdbV0040GetWckeys Get wckey list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040GetWckeysRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040GetWckeys(ctx context.Context) SlurmdbAPISlurmdbV0040GetWckeysRequest {
	return SlurmdbAPISlurmdbV0040GetWckeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiWckeyResp
func (a *SlurmdbAPIService) SlurmdbV0040GetWckeysExecute(r SlurmdbAPISlurmdbV0040GetWckeysRequest) (*V0040OpenapiWckeyResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiWckeyResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040GetWckeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/wckeys/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiWckeyResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040PostAccountsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0040OpenapiAccountsResp *V0040OpenapiAccountsResp
}

// Description of accounts to update/create
func (r SlurmdbAPISlurmdbV0040PostAccountsRequest) V0040OpenapiAccountsResp(v0040OpenapiAccountsResp V0040OpenapiAccountsResp) SlurmdbAPISlurmdbV0040PostAccountsRequest {
	r.v0040OpenapiAccountsResp = &v0040OpenapiAccountsResp
	return r
}

func (r SlurmdbAPISlurmdbV0040PostAccountsRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostAccountsExecute(r)
}

/*
SlurmdbV0040PostAccounts Add/update list of accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040PostAccountsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostAccounts(ctx context.Context) SlurmdbAPISlurmdbV0040PostAccountsRequest {
	return SlurmdbAPISlurmdbV0040PostAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostAccountsExecute(r SlurmdbAPISlurmdbV0040PostAccountsRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/accounts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiAccountsResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040PostAccountsAssociationRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0040OpenapiAccountsAddCondResp *V0040OpenapiAccountsAddCondResp
}

// Add list of accounts with conditional association
func (r SlurmdbAPISlurmdbV0040PostAccountsAssociationRequest) V0040OpenapiAccountsAddCondResp(v0040OpenapiAccountsAddCondResp V0040OpenapiAccountsAddCondResp) SlurmdbAPISlurmdbV0040PostAccountsAssociationRequest {
	r.v0040OpenapiAccountsAddCondResp = &v0040OpenapiAccountsAddCondResp
	return r
}

func (r SlurmdbAPISlurmdbV0040PostAccountsAssociationRequest) Execute() (*V0040OpenapiAccountsAddCondRespStr, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostAccountsAssociationExecute(r)
}

/*
SlurmdbV0040PostAccountsAssociation Add accounts with conditional association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040PostAccountsAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostAccountsAssociation(ctx context.Context) SlurmdbAPISlurmdbV0040PostAccountsAssociationRequest {
	return SlurmdbAPISlurmdbV0040PostAccountsAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiAccountsAddCondRespStr
func (a *SlurmdbAPIService) SlurmdbV0040PostAccountsAssociationExecute(r SlurmdbAPISlurmdbV0040PostAccountsAssociationRequest) (*V0040OpenapiAccountsAddCondRespStr, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiAccountsAddCondRespStr
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostAccountsAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/accounts_association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiAccountsAddCondResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiAccountsAddCondRespStr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040PostAssociationsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0040OpenapiAssocsResp *V0040OpenapiAssocsResp
}

// Job description
func (r SlurmdbAPISlurmdbV0040PostAssociationsRequest) V0040OpenapiAssocsResp(v0040OpenapiAssocsResp V0040OpenapiAssocsResp) SlurmdbAPISlurmdbV0040PostAssociationsRequest {
	r.v0040OpenapiAssocsResp = &v0040OpenapiAssocsResp
	return r
}

func (r SlurmdbAPISlurmdbV0040PostAssociationsRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostAssociationsExecute(r)
}

/*
SlurmdbV0040PostAssociations Set associations info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040PostAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostAssociations(ctx context.Context) SlurmdbAPISlurmdbV0040PostAssociationsRequest {
	return SlurmdbAPISlurmdbV0040PostAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostAssociationsExecute(r SlurmdbAPISlurmdbV0040PostAssociationsRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiAssocsResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040PostClustersRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	updateTime *string
	v0040OpenapiClustersResp *V0040OpenapiClustersResp
}

// Filter reservations since update timestamp
func (r SlurmdbAPISlurmdbV0040PostClustersRequest) UpdateTime(updateTime string) SlurmdbAPISlurmdbV0040PostClustersRequest {
	r.updateTime = &updateTime
	return r
}

// Cluster add or update descriptions
func (r SlurmdbAPISlurmdbV0040PostClustersRequest) V0040OpenapiClustersResp(v0040OpenapiClustersResp V0040OpenapiClustersResp) SlurmdbAPISlurmdbV0040PostClustersRequest {
	r.v0040OpenapiClustersResp = &v0040OpenapiClustersResp
	return r
}

func (r SlurmdbAPISlurmdbV0040PostClustersRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostClustersExecute(r)
}

/*
SlurmdbV0040PostClusters Get cluster list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040PostClustersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostClusters(ctx context.Context) SlurmdbAPISlurmdbV0040PostClustersRequest {
	return SlurmdbAPISlurmdbV0040PostClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostClustersExecute(r SlurmdbAPISlurmdbV0040PostClustersRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiClustersResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040PostConfigRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0040OpenapiSlurmdbdConfigResp *V0040OpenapiSlurmdbdConfigResp
}

// Add or update config
func (r SlurmdbAPISlurmdbV0040PostConfigRequest) V0040OpenapiSlurmdbdConfigResp(v0040OpenapiSlurmdbdConfigResp V0040OpenapiSlurmdbdConfigResp) SlurmdbAPISlurmdbV0040PostConfigRequest {
	r.v0040OpenapiSlurmdbdConfigResp = &v0040OpenapiSlurmdbdConfigResp
	return r
}

func (r SlurmdbAPISlurmdbV0040PostConfigRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostConfigExecute(r)
}

/*
SlurmdbV0040PostConfig Load all configuration information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040PostConfigRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostConfig(ctx context.Context) SlurmdbAPISlurmdbV0040PostConfigRequest {
	return SlurmdbAPISlurmdbV0040PostConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostConfigExecute(r SlurmdbAPISlurmdbV0040PostConfigRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiSlurmdbdConfigResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040PostQosRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	description *string
	id *string
	format *string
	name *string
	preemptMode *string
	withDeleted *string
	v0040OpenapiSlurmdbdQosResp *V0040OpenapiSlurmdbdQosResp
}

// CSV description list
func (r SlurmdbAPISlurmdbV0040PostQosRequest) Description(description string) SlurmdbAPISlurmdbV0040PostQosRequest {
	r.description = &description
	return r
}

// CSV QOS id list
func (r SlurmdbAPISlurmdbV0040PostQosRequest) Id(id string) SlurmdbAPISlurmdbV0040PostQosRequest {
	r.id = &id
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0040PostQosRequest) Format(format string) SlurmdbAPISlurmdbV0040PostQosRequest {
	r.format = &format
	return r
}

// CSV QOS name list
func (r SlurmdbAPISlurmdbV0040PostQosRequest) Name(name string) SlurmdbAPISlurmdbV0040PostQosRequest {
	r.name = &name
	return r
}

// PreemptMode used when jobs in this QOS are preempted
func (r SlurmdbAPISlurmdbV0040PostQosRequest) PreemptMode(preemptMode string) SlurmdbAPISlurmdbV0040PostQosRequest {
	r.preemptMode = &preemptMode
	return r
}

// Include deleted QOS
func (r SlurmdbAPISlurmdbV0040PostQosRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040PostQosRequest {
	r.withDeleted = &withDeleted
	return r
}

// Description of QOS to add or update
func (r SlurmdbAPISlurmdbV0040PostQosRequest) V0040OpenapiSlurmdbdQosResp(v0040OpenapiSlurmdbdQosResp V0040OpenapiSlurmdbdQosResp) SlurmdbAPISlurmdbV0040PostQosRequest {
	r.v0040OpenapiSlurmdbdQosResp = &v0040OpenapiSlurmdbdQosResp
	return r
}

func (r SlurmdbAPISlurmdbV0040PostQosRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostQosExecute(r)
}

/*
SlurmdbV0040PostQos Add or update QOSs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040PostQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostQos(ctx context.Context) SlurmdbAPISlurmdbV0040PostQosRequest {
	return SlurmdbAPISlurmdbV0040PostQosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostQosExecute(r SlurmdbAPISlurmdbV0040PostQosRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/qos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.preemptMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preempt_mode", r.preemptMode, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiSlurmdbdQosResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040PostTresRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0040OpenapiTresResp *V0040OpenapiTresResp
}

// TRES descriptions. Only works in developer mode.
func (r SlurmdbAPISlurmdbV0040PostTresRequest) V0040OpenapiTresResp(v0040OpenapiTresResp V0040OpenapiTresResp) SlurmdbAPISlurmdbV0040PostTresRequest {
	r.v0040OpenapiTresResp = &v0040OpenapiTresResp
	return r
}

func (r SlurmdbAPISlurmdbV0040PostTresRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostTresExecute(r)
}

/*
SlurmdbV0040PostTres Add TRES

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040PostTresRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostTres(ctx context.Context) SlurmdbAPISlurmdbV0040PostTresRequest {
	return SlurmdbAPISlurmdbV0040PostTresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostTresExecute(r SlurmdbAPISlurmdbV0040PostTresRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostTres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/tres/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiTresResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040PostUsersRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0040OpenapiUsersResp *V0040OpenapiUsersResp
}

// add or update user
func (r SlurmdbAPISlurmdbV0040PostUsersRequest) V0040OpenapiUsersResp(v0040OpenapiUsersResp V0040OpenapiUsersResp) SlurmdbAPISlurmdbV0040PostUsersRequest {
	r.v0040OpenapiUsersResp = &v0040OpenapiUsersResp
	return r
}

func (r SlurmdbAPISlurmdbV0040PostUsersRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostUsersExecute(r)
}

/*
SlurmdbV0040PostUsers Update users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040PostUsersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostUsers(ctx context.Context) SlurmdbAPISlurmdbV0040PostUsersRequest {
	return SlurmdbAPISlurmdbV0040PostUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostUsersExecute(r SlurmdbAPISlurmdbV0040PostUsersRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiUsersResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040PostUsersAssociationRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	updateTime *string
	flags *string
	v0040OpenapiUsersAddCondResp *V0040OpenapiUsersAddCondResp
}

// Filter partitions since update timestamp
func (r SlurmdbAPISlurmdbV0040PostUsersAssociationRequest) UpdateTime(updateTime string) SlurmdbAPISlurmdbV0040PostUsersAssociationRequest {
	r.updateTime = &updateTime
	return r
}

// Query flags
func (r SlurmdbAPISlurmdbV0040PostUsersAssociationRequest) Flags(flags string) SlurmdbAPISlurmdbV0040PostUsersAssociationRequest {
	r.flags = &flags
	return r
}

// Create users with conditional association
func (r SlurmdbAPISlurmdbV0040PostUsersAssociationRequest) V0040OpenapiUsersAddCondResp(v0040OpenapiUsersAddCondResp V0040OpenapiUsersAddCondResp) SlurmdbAPISlurmdbV0040PostUsersAssociationRequest {
	r.v0040OpenapiUsersAddCondResp = &v0040OpenapiUsersAddCondResp
	return r
}

func (r SlurmdbAPISlurmdbV0040PostUsersAssociationRequest) Execute() (*V0040OpenapiUsersAddCondRespStr, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostUsersAssociationExecute(r)
}

/*
SlurmdbV0040PostUsersAssociation Add users with conditional association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040PostUsersAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostUsersAssociation(ctx context.Context) SlurmdbAPISlurmdbV0040PostUsersAssociationRequest {
	return SlurmdbAPISlurmdbV0040PostUsersAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiUsersAddCondRespStr
func (a *SlurmdbAPIService) SlurmdbV0040PostUsersAssociationExecute(r SlurmdbAPISlurmdbV0040PostUsersAssociationRequest) (*V0040OpenapiUsersAddCondRespStr, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiUsersAddCondRespStr
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostUsersAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/users_association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "form", "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiUsersAddCondResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiUsersAddCondRespStr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0040PostWckeysRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	cluster *string
	format *string
	id *string
	name *string
	onlyDefaults *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	v0040OpenapiWckeyResp *V0040OpenapiWckeyResp
}

// CSV cluster name list
func (r SlurmdbAPISlurmdbV0040PostWckeysRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0040PostWckeysRequest {
	r.cluster = &cluster
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0040PostWckeysRequest) Format(format string) SlurmdbAPISlurmdbV0040PostWckeysRequest {
	r.format = &format
	return r
}

// CSV id list
func (r SlurmdbAPISlurmdbV0040PostWckeysRequest) Id(id string) SlurmdbAPISlurmdbV0040PostWckeysRequest {
	r.id = &id
	return r
}

// CSV name list
func (r SlurmdbAPISlurmdbV0040PostWckeysRequest) Name(name string) SlurmdbAPISlurmdbV0040PostWckeysRequest {
	r.name = &name
	return r
}

// Only query defaults
func (r SlurmdbAPISlurmdbV0040PostWckeysRequest) OnlyDefaults(onlyDefaults string) SlurmdbAPISlurmdbV0040PostWckeysRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040PostWckeysRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0040PostWckeysRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0040PostWckeysRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0040PostWckeysRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0040PostWckeysRequest) User(user string) SlurmdbAPISlurmdbV0040PostWckeysRequest {
	r.user = &user
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0040PostWckeysRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0040PostWckeysRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted wckeys
func (r SlurmdbAPISlurmdbV0040PostWckeysRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0040PostWckeysRequest {
	r.withDeleted = &withDeleted
	return r
}

// wckeys description
func (r SlurmdbAPISlurmdbV0040PostWckeysRequest) V0040OpenapiWckeyResp(v0040OpenapiWckeyResp V0040OpenapiWckeyResp) SlurmdbAPISlurmdbV0040PostWckeysRequest {
	r.v0040OpenapiWckeyResp = &v0040OpenapiWckeyResp
	return r
}

func (r SlurmdbAPISlurmdbV0040PostWckeysRequest) Execute() (*V0040OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0040PostWckeysExecute(r)
}

/*
SlurmdbV0040PostWckeys Add or update wckeys

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0040PostWckeysRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0040PostWckeys(ctx context.Context) SlurmdbAPISlurmdbV0040PostWckeysRequest {
	return SlurmdbAPISlurmdbV0040PostWckeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0040OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0040PostWckeysExecute(r SlurmdbAPISlurmdbV0040PostWckeysRequest) (*V0040OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0040OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0040PostWckeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.40/wckeys/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0040OpenapiWckeyResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0040OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041DeleteAccountRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	accountName string
}

func (r SlurmdbAPISlurmdbV0041DeleteAccountRequest) Execute() (*V0041OpenapiAccountsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteAccountExecute(r)
}

/*
SlurmdbV0041DeleteAccount Delete account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName Account name
 @return SlurmdbAPISlurmdbV0041DeleteAccountRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAccount(ctx context.Context, accountName string) SlurmdbAPISlurmdbV0041DeleteAccountRequest {
	return SlurmdbAPISlurmdbV0041DeleteAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return V0041OpenapiAccountsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAccountExecute(r SlurmdbAPISlurmdbV0041DeleteAccountRequest) (*V0041OpenapiAccountsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAccountsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/account/{account_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_name"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAccountsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041DeleteAssociationRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) Account(account string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) DefaultQos(defaultQos string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.defaultQos = &defaultQos
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) Format(format string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.format = &format
	return r
}

// CSV id list
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) Id(id string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.id = &id
	return r
}

// Filter to only defaults
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) OnlyDefaults(onlyDefaults string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) ParentAccount(parentAccount string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) Partition(partition string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) Qos(qos string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) User(user string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.user = &user
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted associations
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include a raw qos or delta_qos
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) WithRawQos(withRawQos string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.withRawQos = &withRawQos
	return r
}

// Include sub acct information
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) WithSubAccts(withSubAccts string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// Exclude parent id/name
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) WithoutParentInfo(withoutParentInfo string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// Exclude limits from parents
func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) WithoutParentLimits(withoutParentLimits string) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) Execute() (*V0041OpenapiAssocsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteAssociationExecute(r)
}

/*
SlurmdbV0041DeleteAssociation Delete association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041DeleteAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAssociation(ctx context.Context) SlurmdbAPISlurmdbV0041DeleteAssociationRequest {
	return SlurmdbAPISlurmdbV0041DeleteAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAssocsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAssociationExecute(r SlurmdbAPISlurmdbV0041DeleteAssociationRequest) (*V0041OpenapiAssocsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAssocsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "form", "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "form", "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "form", "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAssocsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041DeleteAssociationsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) Account(account string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) DefaultQos(defaultQos string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.defaultQos = &defaultQos
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) Format(format string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.format = &format
	return r
}

// CSV id list
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) Id(id string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.id = &id
	return r
}

// Filter to only defaults
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) OnlyDefaults(onlyDefaults string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) ParentAccount(parentAccount string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) Partition(partition string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) Qos(qos string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) User(user string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.user = &user
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted associations
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include a raw qos or delta_qos
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) WithRawQos(withRawQos string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.withRawQos = &withRawQos
	return r
}

// Include sub acct information
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) WithSubAccts(withSubAccts string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// Exclude parent id/name
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) WithoutParentInfo(withoutParentInfo string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// Exclude limits from parents
func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) WithoutParentLimits(withoutParentLimits string) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) Execute() (*V0041OpenapiAssocsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteAssociationsExecute(r)
}

/*
SlurmdbV0041DeleteAssociations Delete associations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041DeleteAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAssociations(ctx context.Context) SlurmdbAPISlurmdbV0041DeleteAssociationsRequest {
	return SlurmdbAPISlurmdbV0041DeleteAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAssocsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteAssociationsExecute(r SlurmdbAPISlurmdbV0041DeleteAssociationsRequest) (*V0041OpenapiAssocsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAssocsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "form", "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "form", "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "form", "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAssocsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041DeleteClusterRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	clusterName string
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

// Type of machine
func (r SlurmdbAPISlurmdbV0041DeleteClusterRequest) Classification(classification string) SlurmdbAPISlurmdbV0041DeleteClusterRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r SlurmdbAPISlurmdbV0041DeleteClusterRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0041DeleteClusterRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r SlurmdbAPISlurmdbV0041DeleteClusterRequest) Federation(federation string) SlurmdbAPISlurmdbV0041DeleteClusterRequest {
	r.federation = &federation
	return r
}

// Query flags
func (r SlurmdbAPISlurmdbV0041DeleteClusterRequest) Flags(flags string) SlurmdbAPISlurmdbV0041DeleteClusterRequest {
	r.flags = &flags
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0041DeleteClusterRequest) Format(format string) SlurmdbAPISlurmdbV0041DeleteClusterRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r SlurmdbAPISlurmdbV0041DeleteClusterRequest) RpcVersion(rpcVersion string) SlurmdbAPISlurmdbV0041DeleteClusterRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041DeleteClusterRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0041DeleteClusterRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041DeleteClusterRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0041DeleteClusterRequest {
	r.usageStart = &usageStart
	return r
}

// Include deleted clusters
func (r SlurmdbAPISlurmdbV0041DeleteClusterRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0041DeleteClusterRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0041DeleteClusterRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0041DeleteClusterRequest {
	r.withUsage = &withUsage
	return r
}

func (r SlurmdbAPISlurmdbV0041DeleteClusterRequest) Execute() (*V0041OpenapiClustersRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteClusterExecute(r)
}

/*
SlurmdbV0041DeleteCluster Delete cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName Cluster name
 @return SlurmdbAPISlurmdbV0041DeleteClusterRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteCluster(ctx context.Context, clusterName string) SlurmdbAPISlurmdbV0041DeleteClusterRequest {
	return SlurmdbAPISlurmdbV0041DeleteClusterRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return V0041OpenapiClustersRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteClusterExecute(r SlurmdbAPISlurmdbV0041DeleteClusterRequest) (*V0041OpenapiClustersRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiClustersRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/cluster/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "form", "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiClustersRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041DeleteSingleQosRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	qos string
}

func (r SlurmdbAPISlurmdbV0041DeleteSingleQosRequest) Execute() (*V0041OpenapiSlurmdbdQosRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteSingleQosExecute(r)
}

/*
SlurmdbV0041DeleteSingleQos Delete QOS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param qos QOS name
 @return SlurmdbAPISlurmdbV0041DeleteSingleQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteSingleQos(ctx context.Context, qos string) SlurmdbAPISlurmdbV0041DeleteSingleQosRequest {
	return SlurmdbAPISlurmdbV0041DeleteSingleQosRequest{
		ApiService: a,
		ctx: ctx,
		qos: qos,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdQosRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteSingleQosExecute(r SlurmdbAPISlurmdbV0041DeleteSingleQosRequest) (*V0041OpenapiSlurmdbdQosRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdQosRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteSingleQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/qos/{qos}"
	localVarPath = strings.Replace(localVarPath, "{"+"qos"+"}", url.PathEscape(parameterValueToString(r.qos, "qos")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdQosRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041DeleteUserRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	name string
}

func (r SlurmdbAPISlurmdbV0041DeleteUserRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteUserExecute(r)
}

/*
SlurmdbV0041DeleteUser Delete user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name User name
 @return SlurmdbAPISlurmdbV0041DeleteUserRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteUser(ctx context.Context, name string) SlurmdbAPISlurmdbV0041DeleteUserRequest {
	return SlurmdbAPISlurmdbV0041DeleteUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteUserExecute(r SlurmdbAPISlurmdbV0041DeleteUserRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/user/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041DeleteWckeyRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	id string
}

func (r SlurmdbAPISlurmdbV0041DeleteWckeyRequest) Execute() (*V0041OpenapiWckeyRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041DeleteWckeyExecute(r)
}

/*
SlurmdbV0041DeleteWckey Delete wckey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id wckey id
 @return SlurmdbAPISlurmdbV0041DeleteWckeyRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041DeleteWckey(ctx context.Context, id string) SlurmdbAPISlurmdbV0041DeleteWckeyRequest {
	return SlurmdbAPISlurmdbV0041DeleteWckeyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V0041OpenapiWckeyRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0041DeleteWckeyExecute(r SlurmdbAPISlurmdbV0041DeleteWckeyRequest) (*V0041OpenapiWckeyRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiWckeyRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041DeleteWckey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/wckey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiWckeyRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetAccountRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	accountName string
	withAssocs *string
	withCoords *string
	withDeleted *string
}

// Include associations
func (r SlurmdbAPISlurmdbV0041GetAccountRequest) WithAssocs(withAssocs string) SlurmdbAPISlurmdbV0041GetAccountRequest {
	r.withAssocs = &withAssocs
	return r
}

// Include coordinators
func (r SlurmdbAPISlurmdbV0041GetAccountRequest) WithCoords(withCoords string) SlurmdbAPISlurmdbV0041GetAccountRequest {
	r.withCoords = &withCoords
	return r
}

// Include deleted
func (r SlurmdbAPISlurmdbV0041GetAccountRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0041GetAccountRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r SlurmdbAPISlurmdbV0041GetAccountRequest) Execute() (*V0041OpenapiAccountsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetAccountExecute(r)
}

/*
SlurmdbV0041GetAccount Get account info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName Account name
 @return SlurmdbAPISlurmdbV0041GetAccountRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetAccount(ctx context.Context, accountName string) SlurmdbAPISlurmdbV0041GetAccountRequest {
	return SlurmdbAPISlurmdbV0041GetAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return V0041OpenapiAccountsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetAccountExecute(r SlurmdbAPISlurmdbV0041GetAccountRequest) (*V0041OpenapiAccountsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAccountsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/account/{account_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_name"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "form", "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAccountsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetAccountsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	description *string
	dELETED *string
	withAssociations *string
	withCoordinators *string
	noUsersAreCoords *string
	usersAreCoords *string
}

// CSV description list
func (r SlurmdbAPISlurmdbV0041GetAccountsRequest) Description(description string) SlurmdbAPISlurmdbV0041GetAccountsRequest {
	r.description = &description
	return r
}

// include deleted associations
func (r SlurmdbAPISlurmdbV0041GetAccountsRequest) DELETED(dELETED string) SlurmdbAPISlurmdbV0041GetAccountsRequest {
	r.dELETED = &dELETED
	return r
}

// query includes associations
func (r SlurmdbAPISlurmdbV0041GetAccountsRequest) WithAssociations(withAssociations string) SlurmdbAPISlurmdbV0041GetAccountsRequest {
	r.withAssociations = &withAssociations
	return r
}

// query includes coordinators
func (r SlurmdbAPISlurmdbV0041GetAccountsRequest) WithCoordinators(withCoordinators string) SlurmdbAPISlurmdbV0041GetAccountsRequest {
	r.withCoordinators = &withCoordinators
	return r
}

// remove users as coordinators
func (r SlurmdbAPISlurmdbV0041GetAccountsRequest) NoUsersAreCoords(noUsersAreCoords string) SlurmdbAPISlurmdbV0041GetAccountsRequest {
	r.noUsersAreCoords = &noUsersAreCoords
	return r
}

// users are coordinators
func (r SlurmdbAPISlurmdbV0041GetAccountsRequest) UsersAreCoords(usersAreCoords string) SlurmdbAPISlurmdbV0041GetAccountsRequest {
	r.usersAreCoords = &usersAreCoords
	return r
}

func (r SlurmdbAPISlurmdbV0041GetAccountsRequest) Execute() (*V0041OpenapiAccountsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetAccountsExecute(r)
}

/*
SlurmdbV0041GetAccounts Get account list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041GetAccountsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetAccounts(ctx context.Context) SlurmdbAPISlurmdbV0041GetAccountsRequest {
	return SlurmdbAPISlurmdbV0041GetAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAccountsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetAccountsExecute(r SlurmdbAPISlurmdbV0041GetAccountsRequest) (*V0041OpenapiAccountsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAccountsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/accounts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.dELETED != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DELETED", r.dELETED, "form", "")
	}
	if r.withAssociations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "WithAssociations", r.withAssociations, "form", "")
	}
	if r.withCoordinators != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "WithCoordinators", r.withCoordinators, "form", "")
	}
	if r.noUsersAreCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NoUsersAreCoords", r.noUsersAreCoords, "form", "")
	}
	if r.usersAreCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UsersAreCoords", r.usersAreCoords, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAccountsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetAssociationRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) Account(account string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) DefaultQos(defaultQos string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.defaultQos = &defaultQos
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) Format(format string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.format = &format
	return r
}

// CSV id list
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) Id(id string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.id = &id
	return r
}

// Filter to only defaults
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) OnlyDefaults(onlyDefaults string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) ParentAccount(parentAccount string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) Partition(partition string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) Qos(qos string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) User(user string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.user = &user
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted associations
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include a raw qos or delta_qos
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) WithRawQos(withRawQos string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.withRawQos = &withRawQos
	return r
}

// Include sub acct information
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) WithSubAccts(withSubAccts string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// Exclude parent id/name
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) WithoutParentInfo(withoutParentInfo string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// Exclude limits from parents
func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) WithoutParentLimits(withoutParentLimits string) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r SlurmdbAPISlurmdbV0041GetAssociationRequest) Execute() (*V0041OpenapiAssocsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetAssociationExecute(r)
}

/*
SlurmdbV0041GetAssociation Get association info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041GetAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetAssociation(ctx context.Context) SlurmdbAPISlurmdbV0041GetAssociationRequest {
	return SlurmdbAPISlurmdbV0041GetAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAssocsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetAssociationExecute(r SlurmdbAPISlurmdbV0041GetAssociationRequest) (*V0041OpenapiAssocsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAssocsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "form", "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "form", "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "form", "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAssocsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetAssociationsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	cluster *string
	defaultQos *string
	format *string
	id *string
	onlyDefaults *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	withRawQos *string
	withSubAccts *string
	withoutParentInfo *string
	withoutParentLimits *string
}

// CSV accounts list
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) Account(account string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) DefaultQos(defaultQos string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.defaultQos = &defaultQos
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) Format(format string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.format = &format
	return r
}

// CSV id list
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) Id(id string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.id = &id
	return r
}

// Filter to only defaults
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) OnlyDefaults(onlyDefaults string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// CSV names of parent account
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) ParentAccount(parentAccount string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) Partition(partition string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) Qos(qos string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) User(user string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.user = &user
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted associations
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include a raw qos or delta_qos
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) WithRawQos(withRawQos string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.withRawQos = &withRawQos
	return r
}

// Include sub acct information
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) WithSubAccts(withSubAccts string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.withSubAccts = &withSubAccts
	return r
}

// Exclude parent id/name
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) WithoutParentInfo(withoutParentInfo string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.withoutParentInfo = &withoutParentInfo
	return r
}

// Exclude limits from parents
func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) WithoutParentLimits(withoutParentLimits string) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	r.withoutParentLimits = &withoutParentLimits
	return r
}

func (r SlurmdbAPISlurmdbV0041GetAssociationsRequest) Execute() (*V0041OpenapiAssocsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetAssociationsExecute(r)
}

/*
SlurmdbV0041GetAssociations Get association list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041GetAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetAssociations(ctx context.Context) SlurmdbAPISlurmdbV0041GetAssociationsRequest {
	return SlurmdbAPISlurmdbV0041GetAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAssocsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetAssociationsExecute(r SlurmdbAPISlurmdbV0041GetAssociationsRequest) (*V0041OpenapiAssocsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAssocsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withRawQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_raw_qos", r.withRawQos, "form", "")
	}
	if r.withSubAccts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_sub_accts", r.withSubAccts, "form", "")
	}
	if r.withoutParentInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_info", r.withoutParentInfo, "form", "")
	}
	if r.withoutParentLimits != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_parent_limits", r.withoutParentLimits, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAssocsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetClusterRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	clusterName string
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

// Type of machine
func (r SlurmdbAPISlurmdbV0041GetClusterRequest) Classification(classification string) SlurmdbAPISlurmdbV0041GetClusterRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r SlurmdbAPISlurmdbV0041GetClusterRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0041GetClusterRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r SlurmdbAPISlurmdbV0041GetClusterRequest) Federation(federation string) SlurmdbAPISlurmdbV0041GetClusterRequest {
	r.federation = &federation
	return r
}

// Query flags
func (r SlurmdbAPISlurmdbV0041GetClusterRequest) Flags(flags string) SlurmdbAPISlurmdbV0041GetClusterRequest {
	r.flags = &flags
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0041GetClusterRequest) Format(format string) SlurmdbAPISlurmdbV0041GetClusterRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r SlurmdbAPISlurmdbV0041GetClusterRequest) RpcVersion(rpcVersion string) SlurmdbAPISlurmdbV0041GetClusterRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041GetClusterRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0041GetClusterRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041GetClusterRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0041GetClusterRequest {
	r.usageStart = &usageStart
	return r
}

// Include deleted clusters
func (r SlurmdbAPISlurmdbV0041GetClusterRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0041GetClusterRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0041GetClusterRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0041GetClusterRequest {
	r.withUsage = &withUsage
	return r
}

func (r SlurmdbAPISlurmdbV0041GetClusterRequest) Execute() (*V0041OpenapiClustersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetClusterExecute(r)
}

/*
SlurmdbV0041GetCluster Get cluster info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName Cluster name
 @return SlurmdbAPISlurmdbV0041GetClusterRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetCluster(ctx context.Context, clusterName string) SlurmdbAPISlurmdbV0041GetClusterRequest {
	return SlurmdbAPISlurmdbV0041GetClusterRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return V0041OpenapiClustersResp
func (a *SlurmdbAPIService) SlurmdbV0041GetClusterExecute(r SlurmdbAPISlurmdbV0041GetClusterRequest) (*V0041OpenapiClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/cluster/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "form", "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiClustersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetClustersRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	updateTime *string
}

// Filter reservations since update timestamp
func (r SlurmdbAPISlurmdbV0041GetClustersRequest) UpdateTime(updateTime string) SlurmdbAPISlurmdbV0041GetClustersRequest {
	r.updateTime = &updateTime
	return r
}

func (r SlurmdbAPISlurmdbV0041GetClustersRequest) Execute() (*V0041OpenapiClustersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetClustersExecute(r)
}

/*
SlurmdbV0041GetClusters Get cluster list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041GetClustersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetClusters(ctx context.Context) SlurmdbAPISlurmdbV0041GetClustersRequest {
	return SlurmdbAPISlurmdbV0041GetClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiClustersResp
func (a *SlurmdbAPIService) SlurmdbV0041GetClustersExecute(r SlurmdbAPISlurmdbV0041GetClustersRequest) (*V0041OpenapiClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiClustersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetConfigRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
}

func (r SlurmdbAPISlurmdbV0041GetConfigRequest) Execute() (*V0041OpenapiSlurmdbdConfigResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetConfigExecute(r)
}

/*
SlurmdbV0041GetConfig Dump all configuration information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041GetConfigRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetConfig(ctx context.Context) SlurmdbAPISlurmdbV0041GetConfigRequest {
	return SlurmdbAPISlurmdbV0041GetConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdConfigResp
func (a *SlurmdbAPIService) SlurmdbV0041GetConfigExecute(r SlurmdbAPISlurmdbV0041GetConfigRequest) (*V0041OpenapiSlurmdbdConfigResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdConfigResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdConfigResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetDiagRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
}

func (r SlurmdbAPISlurmdbV0041GetDiagRequest) Execute() (*V0041OpenapiSlurmdbdStatsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetDiagExecute(r)
}

/*
SlurmdbV0041GetDiag Get slurmdb diagnostics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041GetDiagRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetDiag(ctx context.Context) SlurmdbAPISlurmdbV0041GetDiagRequest {
	return SlurmdbAPISlurmdbV0041GetDiagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdStatsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetDiagExecute(r SlurmdbAPISlurmdbV0041GetDiagRequest) (*V0041OpenapiSlurmdbdStatsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdStatsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetDiag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/diag/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdStatsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetInstanceRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	cluster *string
	extra *string
	format *string
	instanceId *string
	instanceType *string
	nodeList *string
	timeEnd *string
	timeStart *string
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0041GetInstanceRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0041GetInstanceRequest {
	r.cluster = &cluster
	return r
}

// CSV extra list
func (r SlurmdbAPISlurmdbV0041GetInstanceRequest) Extra(extra string) SlurmdbAPISlurmdbV0041GetInstanceRequest {
	r.extra = &extra
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0041GetInstanceRequest) Format(format string) SlurmdbAPISlurmdbV0041GetInstanceRequest {
	r.format = &format
	return r
}

// CSV instance_id list
func (r SlurmdbAPISlurmdbV0041GetInstanceRequest) InstanceId(instanceId string) SlurmdbAPISlurmdbV0041GetInstanceRequest {
	r.instanceId = &instanceId
	return r
}

// CSV instance_type list
func (r SlurmdbAPISlurmdbV0041GetInstanceRequest) InstanceType(instanceType string) SlurmdbAPISlurmdbV0041GetInstanceRequest {
	r.instanceType = &instanceType
	return r
}

// Ranged node string
func (r SlurmdbAPISlurmdbV0041GetInstanceRequest) NodeList(nodeList string) SlurmdbAPISlurmdbV0041GetInstanceRequest {
	r.nodeList = &nodeList
	return r
}

// Time end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041GetInstanceRequest) TimeEnd(timeEnd string) SlurmdbAPISlurmdbV0041GetInstanceRequest {
	r.timeEnd = &timeEnd
	return r
}

// Time start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041GetInstanceRequest) TimeStart(timeStart string) SlurmdbAPISlurmdbV0041GetInstanceRequest {
	r.timeStart = &timeStart
	return r
}

func (r SlurmdbAPISlurmdbV0041GetInstanceRequest) Execute() (*V0041OpenapiInstancesResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetInstanceExecute(r)
}

/*
SlurmdbV0041GetInstance Get instance info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041GetInstanceRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetInstance(ctx context.Context) SlurmdbAPISlurmdbV0041GetInstanceRequest {
	return SlurmdbAPISlurmdbV0041GetInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiInstancesResp
func (a *SlurmdbAPIService) SlurmdbV0041GetInstanceExecute(r SlurmdbAPISlurmdbV0041GetInstanceRequest) (*V0041OpenapiInstancesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiInstancesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/instance/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.extra != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extra", r.extra, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "form", "")
	}
	if r.instanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_type", r.instanceType, "form", "")
	}
	if r.nodeList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_list", r.nodeList, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiInstancesResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetInstancesRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	cluster *string
	extra *string
	format *string
	instanceId *string
	instanceType *string
	nodeList *string
	timeEnd *string
	timeStart *string
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0041GetInstancesRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0041GetInstancesRequest {
	r.cluster = &cluster
	return r
}

// CSV extra list
func (r SlurmdbAPISlurmdbV0041GetInstancesRequest) Extra(extra string) SlurmdbAPISlurmdbV0041GetInstancesRequest {
	r.extra = &extra
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0041GetInstancesRequest) Format(format string) SlurmdbAPISlurmdbV0041GetInstancesRequest {
	r.format = &format
	return r
}

// CSV instance_id list
func (r SlurmdbAPISlurmdbV0041GetInstancesRequest) InstanceId(instanceId string) SlurmdbAPISlurmdbV0041GetInstancesRequest {
	r.instanceId = &instanceId
	return r
}

// CSV instance_type list
func (r SlurmdbAPISlurmdbV0041GetInstancesRequest) InstanceType(instanceType string) SlurmdbAPISlurmdbV0041GetInstancesRequest {
	r.instanceType = &instanceType
	return r
}

// Ranged node string
func (r SlurmdbAPISlurmdbV0041GetInstancesRequest) NodeList(nodeList string) SlurmdbAPISlurmdbV0041GetInstancesRequest {
	r.nodeList = &nodeList
	return r
}

// Time end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041GetInstancesRequest) TimeEnd(timeEnd string) SlurmdbAPISlurmdbV0041GetInstancesRequest {
	r.timeEnd = &timeEnd
	return r
}

// Time start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041GetInstancesRequest) TimeStart(timeStart string) SlurmdbAPISlurmdbV0041GetInstancesRequest {
	r.timeStart = &timeStart
	return r
}

func (r SlurmdbAPISlurmdbV0041GetInstancesRequest) Execute() (*V0041OpenapiInstancesResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetInstancesExecute(r)
}

/*
SlurmdbV0041GetInstances Get instance list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041GetInstancesRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetInstances(ctx context.Context) SlurmdbAPISlurmdbV0041GetInstancesRequest {
	return SlurmdbAPISlurmdbV0041GetInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiInstancesResp
func (a *SlurmdbAPIService) SlurmdbV0041GetInstancesExecute(r SlurmdbAPISlurmdbV0041GetInstancesRequest) (*V0041OpenapiInstancesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiInstancesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/instances/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.extra != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extra", r.extra, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "form", "")
	}
	if r.instanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_type", r.instanceType, "form", "")
	}
	if r.nodeList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_list", r.nodeList, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiInstancesResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetJobRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	jobId string
}

func (r SlurmdbAPISlurmdbV0041GetJobRequest) Execute() (*V0041OpenapiSlurmdbdJobsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetJobExecute(r)
}

/*
SlurmdbV0041GetJob Get job info

This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId Job id
 @return SlurmdbAPISlurmdbV0041GetJobRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetJob(ctx context.Context, jobId string) SlurmdbAPISlurmdbV0041GetJobRequest {
	return SlurmdbAPISlurmdbV0041GetJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdJobsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetJobExecute(r SlurmdbAPISlurmdbV0041GetJobRequest) (*V0041OpenapiSlurmdbdJobsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdJobsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/job/{job_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdJobsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetJobsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	association *string
	cluster *string
	constraints *string
	schedulerUnset *string
	scheduledOnSubmit *string
	scheduledByMain *string
	scheduledByBackfill *string
	jobStarted *string
	exitCode *string
	showDuplicates *string
	skipSteps *string
	disableTruncateUsageTime *string
	wholeHetjob *string
	disableWholeHetjob *string
	disableWaitForResult *string
	usageTimeAsSubmitTime *string
	showBatchScript *string
	showJobEnvironment *string
	format *string
	groups *string
	jobName *string
	partition *string
	qos *string
	reason *string
	reservation *string
	reservationId *string
	state *string
	step *string
	endTime *string
	startTime *string
	node *string
	users *string
	wckey *string
}

// CSV account list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Account(account string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.account = &account
	return r
}

// CSV association list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Association(association string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.association = &association
	return r
}

// CSV cluster list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.cluster = &cluster
	return r
}

// CSV constraint list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Constraints(constraints string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.constraints = &constraints
	return r
}

// Schedule bits not set
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) SchedulerUnset(schedulerUnset string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.schedulerUnset = &schedulerUnset
	return r
}

// Job was started on submit
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) ScheduledOnSubmit(scheduledOnSubmit string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.scheduledOnSubmit = &scheduledOnSubmit
	return r
}

// Job was started from main scheduler
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) ScheduledByMain(scheduledByMain string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.scheduledByMain = &scheduledByMain
	return r
}

// Job was started from backfill
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) ScheduledByBackfill(scheduledByBackfill string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.scheduledByBackfill = &scheduledByBackfill
	return r
}

// Job start RPC was received
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) JobStarted(jobStarted string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.jobStarted = &jobStarted
	return r
}

// Job exit code (numeric)
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) ExitCode(exitCode string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.exitCode = &exitCode
	return r
}

// Include duplicate job entries
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) ShowDuplicates(showDuplicates string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.showDuplicates = &showDuplicates
	return r
}

// Exclude job step details
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) SkipSteps(skipSteps string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.skipSteps = &skipSteps
	return r
}

// Do not truncate the time to usage_start and usage_end
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) DisableTruncateUsageTime(disableTruncateUsageTime string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.disableTruncateUsageTime = &disableTruncateUsageTime
	return r
}

// Include details on all hetjob components
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) WholeHetjob(wholeHetjob string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.wholeHetjob = &wholeHetjob
	return r
}

// Only show details on specified hetjob components
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) DisableWholeHetjob(disableWholeHetjob string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.disableWholeHetjob = &disableWholeHetjob
	return r
}

// Tell dbd not to wait for the result
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) DisableWaitForResult(disableWaitForResult string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.disableWaitForResult = &disableWaitForResult
	return r
}

// Use usage_time as the submit_time of the job
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) UsageTimeAsSubmitTime(usageTimeAsSubmitTime string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.usageTimeAsSubmitTime = &usageTimeAsSubmitTime
	return r
}

// Include job script
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) ShowBatchScript(showBatchScript string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.showBatchScript = &showBatchScript
	return r
}

// Include job environment
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) ShowJobEnvironment(showJobEnvironment string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.showJobEnvironment = &showJobEnvironment
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Format(format string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.format = &format
	return r
}

// CSV group list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Groups(groups string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.groups = &groups
	return r
}

// CSV job name list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) JobName(jobName string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.jobName = &jobName
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Partition(partition string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.partition = &partition
	return r
}

// CSV QOS name list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Qos(qos string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.qos = &qos
	return r
}

// CSV reason list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Reason(reason string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.reason = &reason
	return r
}

// CSV reservation name list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Reservation(reservation string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.reservation = &reservation
	return r
}

// CSV reservation ID list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) ReservationId(reservationId string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.reservationId = &reservationId
	return r
}

// CSV state list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) State(state string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.state = &state
	return r
}

// CSV step id list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Step(step string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.step = &step
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) EndTime(endTime string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.endTime = &endTime
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) StartTime(startTime string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.startTime = &startTime
	return r
}

// Ranged node string where jobs ran
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Node(node string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.node = &node
	return r
}

// CSV user name list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Users(users string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.users = &users
	return r
}

// CSV wckey list
func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Wckey(wckey string) SlurmdbAPISlurmdbV0041GetJobsRequest {
	r.wckey = &wckey
	return r
}

func (r SlurmdbAPISlurmdbV0041GetJobsRequest) Execute() (*V0041OpenapiSlurmdbdJobsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetJobsExecute(r)
}

/*
SlurmdbV0041GetJobs Get job list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041GetJobsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetJobs(ctx context.Context) SlurmdbAPISlurmdbV0041GetJobsRequest {
	return SlurmdbAPISlurmdbV0041GetJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdJobsResp
func (a *SlurmdbAPIService) SlurmdbV0041GetJobsExecute(r SlurmdbAPISlurmdbV0041GetJobsRequest) (*V0041OpenapiSlurmdbdJobsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdJobsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.association != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "association", r.association, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.constraints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "constraints", r.constraints, "form", "")
	}
	if r.schedulerUnset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduler_unset", r.schedulerUnset, "form", "")
	}
	if r.scheduledOnSubmit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_on_submit", r.scheduledOnSubmit, "form", "")
	}
	if r.scheduledByMain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_by_main", r.scheduledByMain, "form", "")
	}
	if r.scheduledByBackfill != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_by_backfill", r.scheduledByBackfill, "form", "")
	}
	if r.jobStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_started", r.jobStarted, "form", "")
	}
	if r.exitCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exit_code", r.exitCode, "form", "")
	}
	if r.showDuplicates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_duplicates", r.showDuplicates, "form", "")
	}
	if r.skipSteps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_steps", r.skipSteps, "form", "")
	}
	if r.disableTruncateUsageTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_truncate_usage_time", r.disableTruncateUsageTime, "form", "")
	}
	if r.wholeHetjob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "whole_hetjob", r.wholeHetjob, "form", "")
	}
	if r.disableWholeHetjob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_whole_hetjob", r.disableWholeHetjob, "form", "")
	}
	if r.disableWaitForResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_wait_for_result", r.disableWaitForResult, "form", "")
	}
	if r.usageTimeAsSubmitTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_time_as_submit_time", r.usageTimeAsSubmitTime, "form", "")
	}
	if r.showBatchScript != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_batch_script", r.showBatchScript, "form", "")
	}
	if r.showJobEnvironment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_job_environment", r.showJobEnvironment, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.groups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groups", r.groups, "form", "")
	}
	if r.jobName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_name", r.jobName, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.reason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reason", r.reason, "form", "")
	}
	if r.reservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservation", r.reservation, "form", "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservation_id", r.reservationId, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.step != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "step", r.step, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	}
	if r.node != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node", r.node, "form", "")
	}
	if r.users != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "users", r.users, "form", "")
	}
	if r.wckey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wckey", r.wckey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdJobsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetQosRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	description *string
	id *string
	format *string
	name *string
	preemptMode *string
	withDeleted *string
}

// CSV description list
func (r SlurmdbAPISlurmdbV0041GetQosRequest) Description(description string) SlurmdbAPISlurmdbV0041GetQosRequest {
	r.description = &description
	return r
}

// CSV QOS id list
func (r SlurmdbAPISlurmdbV0041GetQosRequest) Id(id string) SlurmdbAPISlurmdbV0041GetQosRequest {
	r.id = &id
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0041GetQosRequest) Format(format string) SlurmdbAPISlurmdbV0041GetQosRequest {
	r.format = &format
	return r
}

// CSV QOS name list
func (r SlurmdbAPISlurmdbV0041GetQosRequest) Name(name string) SlurmdbAPISlurmdbV0041GetQosRequest {
	r.name = &name
	return r
}

// PreemptMode used when jobs in this QOS are preempted
func (r SlurmdbAPISlurmdbV0041GetQosRequest) PreemptMode(preemptMode string) SlurmdbAPISlurmdbV0041GetQosRequest {
	r.preemptMode = &preemptMode
	return r
}

// Include deleted QOS
func (r SlurmdbAPISlurmdbV0041GetQosRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0041GetQosRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r SlurmdbAPISlurmdbV0041GetQosRequest) Execute() (*V0041OpenapiSlurmdbdQosResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetQosExecute(r)
}

/*
SlurmdbV0041GetQos Get QOS list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041GetQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetQos(ctx context.Context) SlurmdbAPISlurmdbV0041GetQosRequest {
	return SlurmdbAPISlurmdbV0041GetQosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdQosResp
func (a *SlurmdbAPIService) SlurmdbV0041GetQosExecute(r SlurmdbAPISlurmdbV0041GetQosRequest) (*V0041OpenapiSlurmdbdQosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdQosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/qos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.preemptMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preempt_mode", r.preemptMode, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdQosResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetSingleQosRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	qos string
	withDeleted *string
}

// Query includes deleted QOS
func (r SlurmdbAPISlurmdbV0041GetSingleQosRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0041GetSingleQosRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r SlurmdbAPISlurmdbV0041GetSingleQosRequest) Execute() (*V0041OpenapiSlurmdbdQosResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetSingleQosExecute(r)
}

/*
SlurmdbV0041GetSingleQos Get QOS info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param qos QOS name
 @return SlurmdbAPISlurmdbV0041GetSingleQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetSingleQos(ctx context.Context, qos string) SlurmdbAPISlurmdbV0041GetSingleQosRequest {
	return SlurmdbAPISlurmdbV0041GetSingleQosRequest{
		ApiService: a,
		ctx: ctx,
		qos: qos,
	}
}

// Execute executes the request
//  @return V0041OpenapiSlurmdbdQosResp
func (a *SlurmdbAPIService) SlurmdbV0041GetSingleQosExecute(r SlurmdbAPISlurmdbV0041GetSingleQosRequest) (*V0041OpenapiSlurmdbdQosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiSlurmdbdQosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetSingleQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/qos/{qos}"
	localVarPath = strings.Replace(localVarPath, "{"+"qos"+"}", url.PathEscape(parameterValueToString(r.qos, "qos")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiSlurmdbdQosResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetTresRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
}

func (r SlurmdbAPISlurmdbV0041GetTresRequest) Execute() (*V0041OpenapiTresResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetTresExecute(r)
}

/*
SlurmdbV0041GetTres Get TRES info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041GetTresRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetTres(ctx context.Context) SlurmdbAPISlurmdbV0041GetTresRequest {
	return SlurmdbAPISlurmdbV0041GetTresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiTresResp
func (a *SlurmdbAPIService) SlurmdbV0041GetTresExecute(r SlurmdbAPISlurmdbV0041GetTresRequest) (*V0041OpenapiTresResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiTresResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetTres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/tres/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiTresResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetUserRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	name string
	withDeleted *string
	withAssocs *string
	withCoords *string
	withWckeys *string
}

// Include deleted users
func (r SlurmdbAPISlurmdbV0041GetUserRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0041GetUserRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include associations
func (r SlurmdbAPISlurmdbV0041GetUserRequest) WithAssocs(withAssocs string) SlurmdbAPISlurmdbV0041GetUserRequest {
	r.withAssocs = &withAssocs
	return r
}

// Include coordinators
func (r SlurmdbAPISlurmdbV0041GetUserRequest) WithCoords(withCoords string) SlurmdbAPISlurmdbV0041GetUserRequest {
	r.withCoords = &withCoords
	return r
}

// Include wckeys
func (r SlurmdbAPISlurmdbV0041GetUserRequest) WithWckeys(withWckeys string) SlurmdbAPISlurmdbV0041GetUserRequest {
	r.withWckeys = &withWckeys
	return r
}

func (r SlurmdbAPISlurmdbV0041GetUserRequest) Execute() (*V0041OpenapiUsersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetUserExecute(r)
}

/*
SlurmdbV0041GetUser Get user info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name User name
 @return SlurmdbAPISlurmdbV0041GetUserRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetUser(ctx context.Context, name string) SlurmdbAPISlurmdbV0041GetUserRequest {
	return SlurmdbAPISlurmdbV0041GetUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V0041OpenapiUsersResp
func (a *SlurmdbAPIService) SlurmdbV0041GetUserExecute(r SlurmdbAPISlurmdbV0041GetUserRequest) (*V0041OpenapiUsersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiUsersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/user/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "form", "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "form", "")
	}
	if r.withWckeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_wckeys", r.withWckeys, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiUsersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetUsersRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	adminLevel *string
	defaultAccount *string
	defaultWckey *string
	withAssocs *string
	withCoords *string
	withDeleted *string
	withWckeys *string
	withoutDefaults *string
}

// Administrator level
func (r SlurmdbAPISlurmdbV0041GetUsersRequest) AdminLevel(adminLevel string) SlurmdbAPISlurmdbV0041GetUsersRequest {
	r.adminLevel = &adminLevel
	return r
}

// CSV default account list
func (r SlurmdbAPISlurmdbV0041GetUsersRequest) DefaultAccount(defaultAccount string) SlurmdbAPISlurmdbV0041GetUsersRequest {
	r.defaultAccount = &defaultAccount
	return r
}

// CSV default wckey list
func (r SlurmdbAPISlurmdbV0041GetUsersRequest) DefaultWckey(defaultWckey string) SlurmdbAPISlurmdbV0041GetUsersRequest {
	r.defaultWckey = &defaultWckey
	return r
}

// With associations
func (r SlurmdbAPISlurmdbV0041GetUsersRequest) WithAssocs(withAssocs string) SlurmdbAPISlurmdbV0041GetUsersRequest {
	r.withAssocs = &withAssocs
	return r
}

// With coordinators
func (r SlurmdbAPISlurmdbV0041GetUsersRequest) WithCoords(withCoords string) SlurmdbAPISlurmdbV0041GetUsersRequest {
	r.withCoords = &withCoords
	return r
}

// With deleted
func (r SlurmdbAPISlurmdbV0041GetUsersRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0041GetUsersRequest {
	r.withDeleted = &withDeleted
	return r
}

// With wckeys
func (r SlurmdbAPISlurmdbV0041GetUsersRequest) WithWckeys(withWckeys string) SlurmdbAPISlurmdbV0041GetUsersRequest {
	r.withWckeys = &withWckeys
	return r
}

// Exclude defaults
func (r SlurmdbAPISlurmdbV0041GetUsersRequest) WithoutDefaults(withoutDefaults string) SlurmdbAPISlurmdbV0041GetUsersRequest {
	r.withoutDefaults = &withoutDefaults
	return r
}

func (r SlurmdbAPISlurmdbV0041GetUsersRequest) Execute() (*V0041OpenapiUsersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetUsersExecute(r)
}

/*
SlurmdbV0041GetUsers Get user list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041GetUsersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetUsers(ctx context.Context) SlurmdbAPISlurmdbV0041GetUsersRequest {
	return SlurmdbAPISlurmdbV0041GetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiUsersResp
func (a *SlurmdbAPIService) SlurmdbV0041GetUsersExecute(r SlurmdbAPISlurmdbV0041GetUsersRequest) (*V0041OpenapiUsersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiUsersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.adminLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "admin_level", r.adminLevel, "form", "")
	}
	if r.defaultAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_account", r.defaultAccount, "form", "")
	}
	if r.defaultWckey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_wckey", r.defaultWckey, "form", "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "form", "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withWckeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_wckeys", r.withWckeys, "form", "")
	}
	if r.withoutDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_defaults", r.withoutDefaults, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiUsersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetWckeyRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	id string
}

func (r SlurmdbAPISlurmdbV0041GetWckeyRequest) Execute() (*V0041OpenapiWckeyResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetWckeyExecute(r)
}

/*
SlurmdbV0041GetWckey Get wckey info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id wckey id
 @return SlurmdbAPISlurmdbV0041GetWckeyRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetWckey(ctx context.Context, id string) SlurmdbAPISlurmdbV0041GetWckeyRequest {
	return SlurmdbAPISlurmdbV0041GetWckeyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V0041OpenapiWckeyResp
func (a *SlurmdbAPIService) SlurmdbV0041GetWckeyExecute(r SlurmdbAPISlurmdbV0041GetWckeyRequest) (*V0041OpenapiWckeyResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiWckeyResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetWckey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/wckey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiWckeyResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041GetWckeysRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	cluster *string
	format *string
	id *string
	name *string
	onlyDefaults *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
}

// CSV cluster name list
func (r SlurmdbAPISlurmdbV0041GetWckeysRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0041GetWckeysRequest {
	r.cluster = &cluster
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0041GetWckeysRequest) Format(format string) SlurmdbAPISlurmdbV0041GetWckeysRequest {
	r.format = &format
	return r
}

// CSV id list
func (r SlurmdbAPISlurmdbV0041GetWckeysRequest) Id(id string) SlurmdbAPISlurmdbV0041GetWckeysRequest {
	r.id = &id
	return r
}

// CSV name list
func (r SlurmdbAPISlurmdbV0041GetWckeysRequest) Name(name string) SlurmdbAPISlurmdbV0041GetWckeysRequest {
	r.name = &name
	return r
}

// Only query defaults
func (r SlurmdbAPISlurmdbV0041GetWckeysRequest) OnlyDefaults(onlyDefaults string) SlurmdbAPISlurmdbV0041GetWckeysRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041GetWckeysRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0041GetWckeysRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041GetWckeysRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0041GetWckeysRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0041GetWckeysRequest) User(user string) SlurmdbAPISlurmdbV0041GetWckeysRequest {
	r.user = &user
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0041GetWckeysRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0041GetWckeysRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted wckeys
func (r SlurmdbAPISlurmdbV0041GetWckeysRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0041GetWckeysRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r SlurmdbAPISlurmdbV0041GetWckeysRequest) Execute() (*V0041OpenapiWckeyResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041GetWckeysExecute(r)
}

/*
SlurmdbV0041GetWckeys Get wckey list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041GetWckeysRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041GetWckeys(ctx context.Context) SlurmdbAPISlurmdbV0041GetWckeysRequest {
	return SlurmdbAPISlurmdbV0041GetWckeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiWckeyResp
func (a *SlurmdbAPIService) SlurmdbV0041GetWckeysExecute(r SlurmdbAPISlurmdbV0041GetWckeysRequest) (*V0041OpenapiWckeyResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiWckeyResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041GetWckeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/wckeys/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiWckeyResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041PostAccountsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0041OpenapiAccountsResp *V0041OpenapiAccountsResp
}

// Description of accounts to update/create
func (r SlurmdbAPISlurmdbV0041PostAccountsRequest) V0041OpenapiAccountsResp(v0041OpenapiAccountsResp V0041OpenapiAccountsResp) SlurmdbAPISlurmdbV0041PostAccountsRequest {
	r.v0041OpenapiAccountsResp = &v0041OpenapiAccountsResp
	return r
}

func (r SlurmdbAPISlurmdbV0041PostAccountsRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostAccountsExecute(r)
}

/*
SlurmdbV0041PostAccounts Add/update list of accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041PostAccountsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostAccounts(ctx context.Context) SlurmdbAPISlurmdbV0041PostAccountsRequest {
	return SlurmdbAPISlurmdbV0041PostAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostAccountsExecute(r SlurmdbAPISlurmdbV0041PostAccountsRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/accounts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiAccountsResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041PostAccountsAssociationRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0041OpenapiAccountsAddCondResp *V0041OpenapiAccountsAddCondResp
}

// Add list of accounts with conditional association
func (r SlurmdbAPISlurmdbV0041PostAccountsAssociationRequest) V0041OpenapiAccountsAddCondResp(v0041OpenapiAccountsAddCondResp V0041OpenapiAccountsAddCondResp) SlurmdbAPISlurmdbV0041PostAccountsAssociationRequest {
	r.v0041OpenapiAccountsAddCondResp = &v0041OpenapiAccountsAddCondResp
	return r
}

func (r SlurmdbAPISlurmdbV0041PostAccountsAssociationRequest) Execute() (*V0041OpenapiAccountsAddCondRespStr, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostAccountsAssociationExecute(r)
}

/*
SlurmdbV0041PostAccountsAssociation Add accounts with conditional association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041PostAccountsAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostAccountsAssociation(ctx context.Context) SlurmdbAPISlurmdbV0041PostAccountsAssociationRequest {
	return SlurmdbAPISlurmdbV0041PostAccountsAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiAccountsAddCondRespStr
func (a *SlurmdbAPIService) SlurmdbV0041PostAccountsAssociationExecute(r SlurmdbAPISlurmdbV0041PostAccountsAssociationRequest) (*V0041OpenapiAccountsAddCondRespStr, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiAccountsAddCondRespStr
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostAccountsAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/accounts_association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiAccountsAddCondResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiAccountsAddCondRespStr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041PostAssociationsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0041OpenapiAssocsResp *V0041OpenapiAssocsResp
}

// Job description
func (r SlurmdbAPISlurmdbV0041PostAssociationsRequest) V0041OpenapiAssocsResp(v0041OpenapiAssocsResp V0041OpenapiAssocsResp) SlurmdbAPISlurmdbV0041PostAssociationsRequest {
	r.v0041OpenapiAssocsResp = &v0041OpenapiAssocsResp
	return r
}

func (r SlurmdbAPISlurmdbV0041PostAssociationsRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostAssociationsExecute(r)
}

/*
SlurmdbV0041PostAssociations Set associations info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041PostAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostAssociations(ctx context.Context) SlurmdbAPISlurmdbV0041PostAssociationsRequest {
	return SlurmdbAPISlurmdbV0041PostAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostAssociationsExecute(r SlurmdbAPISlurmdbV0041PostAssociationsRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiAssocsResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041PostClustersRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	updateTime *string
	v0041OpenapiClustersResp *V0041OpenapiClustersResp
}

// Filter reservations since update timestamp
func (r SlurmdbAPISlurmdbV0041PostClustersRequest) UpdateTime(updateTime string) SlurmdbAPISlurmdbV0041PostClustersRequest {
	r.updateTime = &updateTime
	return r
}

// Cluster add or update descriptions
func (r SlurmdbAPISlurmdbV0041PostClustersRequest) V0041OpenapiClustersResp(v0041OpenapiClustersResp V0041OpenapiClustersResp) SlurmdbAPISlurmdbV0041PostClustersRequest {
	r.v0041OpenapiClustersResp = &v0041OpenapiClustersResp
	return r
}

func (r SlurmdbAPISlurmdbV0041PostClustersRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostClustersExecute(r)
}

/*
SlurmdbV0041PostClusters Get cluster list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041PostClustersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostClusters(ctx context.Context) SlurmdbAPISlurmdbV0041PostClustersRequest {
	return SlurmdbAPISlurmdbV0041PostClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostClustersExecute(r SlurmdbAPISlurmdbV0041PostClustersRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiClustersResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041PostConfigRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0041OpenapiSlurmdbdConfigResp *V0041OpenapiSlurmdbdConfigResp
}

// Add or update config
func (r SlurmdbAPISlurmdbV0041PostConfigRequest) V0041OpenapiSlurmdbdConfigResp(v0041OpenapiSlurmdbdConfigResp V0041OpenapiSlurmdbdConfigResp) SlurmdbAPISlurmdbV0041PostConfigRequest {
	r.v0041OpenapiSlurmdbdConfigResp = &v0041OpenapiSlurmdbdConfigResp
	return r
}

func (r SlurmdbAPISlurmdbV0041PostConfigRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostConfigExecute(r)
}

/*
SlurmdbV0041PostConfig Load all configuration information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041PostConfigRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostConfig(ctx context.Context) SlurmdbAPISlurmdbV0041PostConfigRequest {
	return SlurmdbAPISlurmdbV0041PostConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostConfigExecute(r SlurmdbAPISlurmdbV0041PostConfigRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiSlurmdbdConfigResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041PostQosRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	description *string
	id *string
	format *string
	name *string
	preemptMode *string
	withDeleted *string
	v0041OpenapiSlurmdbdQosResp *V0041OpenapiSlurmdbdQosResp
}

// CSV description list
func (r SlurmdbAPISlurmdbV0041PostQosRequest) Description(description string) SlurmdbAPISlurmdbV0041PostQosRequest {
	r.description = &description
	return r
}

// CSV QOS id list
func (r SlurmdbAPISlurmdbV0041PostQosRequest) Id(id string) SlurmdbAPISlurmdbV0041PostQosRequest {
	r.id = &id
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0041PostQosRequest) Format(format string) SlurmdbAPISlurmdbV0041PostQosRequest {
	r.format = &format
	return r
}

// CSV QOS name list
func (r SlurmdbAPISlurmdbV0041PostQosRequest) Name(name string) SlurmdbAPISlurmdbV0041PostQosRequest {
	r.name = &name
	return r
}

// PreemptMode used when jobs in this QOS are preempted
func (r SlurmdbAPISlurmdbV0041PostQosRequest) PreemptMode(preemptMode string) SlurmdbAPISlurmdbV0041PostQosRequest {
	r.preemptMode = &preemptMode
	return r
}

// Include deleted QOS
func (r SlurmdbAPISlurmdbV0041PostQosRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0041PostQosRequest {
	r.withDeleted = &withDeleted
	return r
}

// Description of QOS to add or update
func (r SlurmdbAPISlurmdbV0041PostQosRequest) V0041OpenapiSlurmdbdQosResp(v0041OpenapiSlurmdbdQosResp V0041OpenapiSlurmdbdQosResp) SlurmdbAPISlurmdbV0041PostQosRequest {
	r.v0041OpenapiSlurmdbdQosResp = &v0041OpenapiSlurmdbdQosResp
	return r
}

func (r SlurmdbAPISlurmdbV0041PostQosRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostQosExecute(r)
}

/*
SlurmdbV0041PostQos Add or update QOSs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041PostQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostQos(ctx context.Context) SlurmdbAPISlurmdbV0041PostQosRequest {
	return SlurmdbAPISlurmdbV0041PostQosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostQosExecute(r SlurmdbAPISlurmdbV0041PostQosRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/qos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.preemptMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preempt_mode", r.preemptMode, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiSlurmdbdQosResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041PostTresRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0041OpenapiTresResp *V0041OpenapiTresResp
}

// TRES descriptions. Only works in developer mode.
func (r SlurmdbAPISlurmdbV0041PostTresRequest) V0041OpenapiTresResp(v0041OpenapiTresResp V0041OpenapiTresResp) SlurmdbAPISlurmdbV0041PostTresRequest {
	r.v0041OpenapiTresResp = &v0041OpenapiTresResp
	return r
}

func (r SlurmdbAPISlurmdbV0041PostTresRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostTresExecute(r)
}

/*
SlurmdbV0041PostTres Add TRES

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041PostTresRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostTres(ctx context.Context) SlurmdbAPISlurmdbV0041PostTresRequest {
	return SlurmdbAPISlurmdbV0041PostTresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostTresExecute(r SlurmdbAPISlurmdbV0041PostTresRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostTres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/tres/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiTresResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041PostUsersRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0041OpenapiUsersResp *V0041OpenapiUsersResp
}

// add or update user
func (r SlurmdbAPISlurmdbV0041PostUsersRequest) V0041OpenapiUsersResp(v0041OpenapiUsersResp V0041OpenapiUsersResp) SlurmdbAPISlurmdbV0041PostUsersRequest {
	r.v0041OpenapiUsersResp = &v0041OpenapiUsersResp
	return r
}

func (r SlurmdbAPISlurmdbV0041PostUsersRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostUsersExecute(r)
}

/*
SlurmdbV0041PostUsers Update users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041PostUsersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostUsers(ctx context.Context) SlurmdbAPISlurmdbV0041PostUsersRequest {
	return SlurmdbAPISlurmdbV0041PostUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostUsersExecute(r SlurmdbAPISlurmdbV0041PostUsersRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiUsersResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041PostUsersAssociationRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	updateTime *string
	flags *string
	v0041OpenapiUsersAddCondResp *V0041OpenapiUsersAddCondResp
}

// Filter partitions since update timestamp
func (r SlurmdbAPISlurmdbV0041PostUsersAssociationRequest) UpdateTime(updateTime string) SlurmdbAPISlurmdbV0041PostUsersAssociationRequest {
	r.updateTime = &updateTime
	return r
}

// Query flags
func (r SlurmdbAPISlurmdbV0041PostUsersAssociationRequest) Flags(flags string) SlurmdbAPISlurmdbV0041PostUsersAssociationRequest {
	r.flags = &flags
	return r
}

// Create users with conditional association
func (r SlurmdbAPISlurmdbV0041PostUsersAssociationRequest) V0041OpenapiUsersAddCondResp(v0041OpenapiUsersAddCondResp V0041OpenapiUsersAddCondResp) SlurmdbAPISlurmdbV0041PostUsersAssociationRequest {
	r.v0041OpenapiUsersAddCondResp = &v0041OpenapiUsersAddCondResp
	return r
}

func (r SlurmdbAPISlurmdbV0041PostUsersAssociationRequest) Execute() (*V0041OpenapiUsersAddCondRespStr, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostUsersAssociationExecute(r)
}

/*
SlurmdbV0041PostUsersAssociation Add users with conditional association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041PostUsersAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostUsersAssociation(ctx context.Context) SlurmdbAPISlurmdbV0041PostUsersAssociationRequest {
	return SlurmdbAPISlurmdbV0041PostUsersAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiUsersAddCondRespStr
func (a *SlurmdbAPIService) SlurmdbV0041PostUsersAssociationExecute(r SlurmdbAPISlurmdbV0041PostUsersAssociationRequest) (*V0041OpenapiUsersAddCondRespStr, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiUsersAddCondRespStr
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostUsersAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/users_association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "form", "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiUsersAddCondResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiUsersAddCondRespStr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0041PostWckeysRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	cluster *string
	format *string
	id *string
	name *string
	onlyDefaults *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	v0041OpenapiWckeyResp *V0041OpenapiWckeyResp
}

// CSV cluster name list
func (r SlurmdbAPISlurmdbV0041PostWckeysRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0041PostWckeysRequest {
	r.cluster = &cluster
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0041PostWckeysRequest) Format(format string) SlurmdbAPISlurmdbV0041PostWckeysRequest {
	r.format = &format
	return r
}

// CSV id list
func (r SlurmdbAPISlurmdbV0041PostWckeysRequest) Id(id string) SlurmdbAPISlurmdbV0041PostWckeysRequest {
	r.id = &id
	return r
}

// CSV name list
func (r SlurmdbAPISlurmdbV0041PostWckeysRequest) Name(name string) SlurmdbAPISlurmdbV0041PostWckeysRequest {
	r.name = &name
	return r
}

// Only query defaults
func (r SlurmdbAPISlurmdbV0041PostWckeysRequest) OnlyDefaults(onlyDefaults string) SlurmdbAPISlurmdbV0041PostWckeysRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041PostWckeysRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0041PostWckeysRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0041PostWckeysRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0041PostWckeysRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0041PostWckeysRequest) User(user string) SlurmdbAPISlurmdbV0041PostWckeysRequest {
	r.user = &user
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0041PostWckeysRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0041PostWckeysRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted wckeys
func (r SlurmdbAPISlurmdbV0041PostWckeysRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0041PostWckeysRequest {
	r.withDeleted = &withDeleted
	return r
}

// wckeys description
func (r SlurmdbAPISlurmdbV0041PostWckeysRequest) V0041OpenapiWckeyResp(v0041OpenapiWckeyResp V0041OpenapiWckeyResp) SlurmdbAPISlurmdbV0041PostWckeysRequest {
	r.v0041OpenapiWckeyResp = &v0041OpenapiWckeyResp
	return r
}

func (r SlurmdbAPISlurmdbV0041PostWckeysRequest) Execute() (*V0041OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0041PostWckeysExecute(r)
}

/*
SlurmdbV0041PostWckeys Add or update wckeys

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0041PostWckeysRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0041PostWckeys(ctx context.Context) SlurmdbAPISlurmdbV0041PostWckeysRequest {
	return SlurmdbAPISlurmdbV0041PostWckeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0041OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0041PostWckeysExecute(r SlurmdbAPISlurmdbV0041PostWckeysRequest) (*V0041OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0041OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0041PostWckeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.41/wckeys/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0041OpenapiWckeyResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0041OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042DeleteAccountRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	accountName string
}

func (r SlurmdbAPISlurmdbV0042DeleteAccountRequest) Execute() (*V0042OpenapiAccountsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042DeleteAccountExecute(r)
}

/*
SlurmdbV0042DeleteAccount Delete account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName Account name
 @return SlurmdbAPISlurmdbV0042DeleteAccountRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042DeleteAccount(ctx context.Context, accountName string) SlurmdbAPISlurmdbV0042DeleteAccountRequest {
	return SlurmdbAPISlurmdbV0042DeleteAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return V0042OpenapiAccountsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0042DeleteAccountExecute(r SlurmdbAPISlurmdbV0042DeleteAccountRequest) (*V0042OpenapiAccountsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiAccountsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042DeleteAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/account/{account_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_name"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiAccountsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042DeleteAssociationRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	cluster *string
	defaultQos *string
	includeDeletedAssociations *string
	includeUsage *string
	filterToOnlyDefaults *string
	includeTheRawQOSOrDeltaQos *string
	includeSubAcctInformation *string
	excludeParentIdName *string
	excludeLimitsFromParents *string
	format *string
	id *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
}

// CSV accounts list
func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) Account(account string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) DefaultQos(defaultQos string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.defaultQos = &defaultQos
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) IncludeDeletedAssociations(includeDeletedAssociations string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.includeDeletedAssociations = &includeDeletedAssociations
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) IncludeUsage(includeUsage string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.includeUsage = &includeUsage
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) FilterToOnlyDefaults(filterToOnlyDefaults string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.filterToOnlyDefaults = &filterToOnlyDefaults
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) IncludeTheRawQOSOrDeltaQos(includeTheRawQOSOrDeltaQos string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.includeTheRawQOSOrDeltaQos = &includeTheRawQOSOrDeltaQos
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) IncludeSubAcctInformation(includeSubAcctInformation string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.includeSubAcctInformation = &includeSubAcctInformation
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) ExcludeParentIdName(excludeParentIdName string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.excludeParentIdName = &excludeParentIdName
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) ExcludeLimitsFromParents(excludeLimitsFromParents string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.excludeLimitsFromParents = &excludeLimitsFromParents
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) Format(format string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.format = &format
	return r
}

// CSV ID list
func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) Id(id string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.id = &id
	return r
}

// CSV names of parent account
func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) ParentAccount(parentAccount string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) Partition(partition string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) Qos(qos string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) User(user string) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	r.user = &user
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) Execute() (*V0042OpenapiAssocsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042DeleteAssociationExecute(r)
}

/*
SlurmdbV0042DeleteAssociation Delete association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042DeleteAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042DeleteAssociation(ctx context.Context) SlurmdbAPISlurmdbV0042DeleteAssociationRequest {
	return SlurmdbAPISlurmdbV0042DeleteAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiAssocsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0042DeleteAssociationExecute(r SlurmdbAPISlurmdbV0042DeleteAssociationRequest) (*V0042OpenapiAssocsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiAssocsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042DeleteAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.includeDeletedAssociations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include deleted associations", r.includeDeletedAssociations, "form", "")
	}
	if r.includeUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include usage", r.includeUsage, "form", "")
	}
	if r.filterToOnlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filter to only defaults", r.filterToOnlyDefaults, "form", "")
	}
	if r.includeTheRawQOSOrDeltaQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include the raw QOS or delta_qos", r.includeTheRawQOSOrDeltaQos, "form", "")
	}
	if r.includeSubAcctInformation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include sub acct information", r.includeSubAcctInformation, "form", "")
	}
	if r.excludeParentIdName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Exclude parent id/name", r.excludeParentIdName, "form", "")
	}
	if r.excludeLimitsFromParents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Exclude limits from parents", r.excludeLimitsFromParents, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiAssocsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042DeleteAssociationsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	cluster *string
	defaultQos *string
	includeDeletedAssociations *string
	includeUsage *string
	filterToOnlyDefaults *string
	includeTheRawQOSOrDeltaQos *string
	includeSubAcctInformation *string
	excludeParentIdName *string
	excludeLimitsFromParents *string
	format *string
	id *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
}

// CSV accounts list
func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) Account(account string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) DefaultQos(defaultQos string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.defaultQos = &defaultQos
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) IncludeDeletedAssociations(includeDeletedAssociations string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.includeDeletedAssociations = &includeDeletedAssociations
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) IncludeUsage(includeUsage string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.includeUsage = &includeUsage
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) FilterToOnlyDefaults(filterToOnlyDefaults string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.filterToOnlyDefaults = &filterToOnlyDefaults
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) IncludeTheRawQOSOrDeltaQos(includeTheRawQOSOrDeltaQos string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.includeTheRawQOSOrDeltaQos = &includeTheRawQOSOrDeltaQos
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) IncludeSubAcctInformation(includeSubAcctInformation string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.includeSubAcctInformation = &includeSubAcctInformation
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) ExcludeParentIdName(excludeParentIdName string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.excludeParentIdName = &excludeParentIdName
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) ExcludeLimitsFromParents(excludeLimitsFromParents string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.excludeLimitsFromParents = &excludeLimitsFromParents
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) Format(format string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.format = &format
	return r
}

// CSV ID list
func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) Id(id string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.id = &id
	return r
}

// CSV names of parent account
func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) ParentAccount(parentAccount string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) Partition(partition string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) Qos(qos string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) User(user string) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	r.user = &user
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) Execute() (*V0042OpenapiAssocsRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042DeleteAssociationsExecute(r)
}

/*
SlurmdbV0042DeleteAssociations Delete associations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042DeleteAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042DeleteAssociations(ctx context.Context) SlurmdbAPISlurmdbV0042DeleteAssociationsRequest {
	return SlurmdbAPISlurmdbV0042DeleteAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiAssocsRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0042DeleteAssociationsExecute(r SlurmdbAPISlurmdbV0042DeleteAssociationsRequest) (*V0042OpenapiAssocsRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiAssocsRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042DeleteAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.includeDeletedAssociations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include deleted associations", r.includeDeletedAssociations, "form", "")
	}
	if r.includeUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include usage", r.includeUsage, "form", "")
	}
	if r.filterToOnlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filter to only defaults", r.filterToOnlyDefaults, "form", "")
	}
	if r.includeTheRawQOSOrDeltaQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include the raw QOS or delta_qos", r.includeTheRawQOSOrDeltaQos, "form", "")
	}
	if r.includeSubAcctInformation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include sub acct information", r.includeSubAcctInformation, "form", "")
	}
	if r.excludeParentIdName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Exclude parent id/name", r.excludeParentIdName, "form", "")
	}
	if r.excludeLimitsFromParents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Exclude limits from parents", r.excludeLimitsFromParents, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiAssocsRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042DeleteClusterRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	clusterName string
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

// Type of machine
func (r SlurmdbAPISlurmdbV0042DeleteClusterRequest) Classification(classification string) SlurmdbAPISlurmdbV0042DeleteClusterRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r SlurmdbAPISlurmdbV0042DeleteClusterRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0042DeleteClusterRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r SlurmdbAPISlurmdbV0042DeleteClusterRequest) Federation(federation string) SlurmdbAPISlurmdbV0042DeleteClusterRequest {
	r.federation = &federation
	return r
}

// Query flags
func (r SlurmdbAPISlurmdbV0042DeleteClusterRequest) Flags(flags string) SlurmdbAPISlurmdbV0042DeleteClusterRequest {
	r.flags = &flags
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0042DeleteClusterRequest) Format(format string) SlurmdbAPISlurmdbV0042DeleteClusterRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r SlurmdbAPISlurmdbV0042DeleteClusterRequest) RpcVersion(rpcVersion string) SlurmdbAPISlurmdbV0042DeleteClusterRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042DeleteClusterRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0042DeleteClusterRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042DeleteClusterRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0042DeleteClusterRequest {
	r.usageStart = &usageStart
	return r
}

// Include deleted clusters
func (r SlurmdbAPISlurmdbV0042DeleteClusterRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0042DeleteClusterRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0042DeleteClusterRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0042DeleteClusterRequest {
	r.withUsage = &withUsage
	return r
}

func (r SlurmdbAPISlurmdbV0042DeleteClusterRequest) Execute() (*V0042OpenapiClustersRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042DeleteClusterExecute(r)
}

/*
SlurmdbV0042DeleteCluster Delete cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName Cluster name
 @return SlurmdbAPISlurmdbV0042DeleteClusterRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042DeleteCluster(ctx context.Context, clusterName string) SlurmdbAPISlurmdbV0042DeleteClusterRequest {
	return SlurmdbAPISlurmdbV0042DeleteClusterRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return V0042OpenapiClustersRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0042DeleteClusterExecute(r SlurmdbAPISlurmdbV0042DeleteClusterRequest) (*V0042OpenapiClustersRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiClustersRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042DeleteCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/cluster/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "form", "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiClustersRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042DeleteSingleQosRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	qos string
}

func (r SlurmdbAPISlurmdbV0042DeleteSingleQosRequest) Execute() (*V0042OpenapiSlurmdbdQosRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042DeleteSingleQosExecute(r)
}

/*
SlurmdbV0042DeleteSingleQos Delete QOS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param qos QOS name
 @return SlurmdbAPISlurmdbV0042DeleteSingleQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042DeleteSingleQos(ctx context.Context, qos string) SlurmdbAPISlurmdbV0042DeleteSingleQosRequest {
	return SlurmdbAPISlurmdbV0042DeleteSingleQosRequest{
		ApiService: a,
		ctx: ctx,
		qos: qos,
	}
}

// Execute executes the request
//  @return V0042OpenapiSlurmdbdQosRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0042DeleteSingleQosExecute(r SlurmdbAPISlurmdbV0042DeleteSingleQosRequest) (*V0042OpenapiSlurmdbdQosRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiSlurmdbdQosRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042DeleteSingleQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/qos/{qos}"
	localVarPath = strings.Replace(localVarPath, "{"+"qos"+"}", url.PathEscape(parameterValueToString(r.qos, "qos")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiSlurmdbdQosRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042DeleteUserRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	name string
}

func (r SlurmdbAPISlurmdbV0042DeleteUserRequest) Execute() (*V0042OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042DeleteUserExecute(r)
}

/*
SlurmdbV0042DeleteUser Delete user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name User name
 @return SlurmdbAPISlurmdbV0042DeleteUserRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042DeleteUser(ctx context.Context, name string) SlurmdbAPISlurmdbV0042DeleteUserRequest {
	return SlurmdbAPISlurmdbV0042DeleteUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V0042OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0042DeleteUserExecute(r SlurmdbAPISlurmdbV0042DeleteUserRequest) (*V0042OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042DeleteUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/user/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042DeleteWckeyRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	id string
}

func (r SlurmdbAPISlurmdbV0042DeleteWckeyRequest) Execute() (*V0042OpenapiWckeyRemovedResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042DeleteWckeyExecute(r)
}

/*
SlurmdbV0042DeleteWckey Delete wckey

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id WCKey ID
 @return SlurmdbAPISlurmdbV0042DeleteWckeyRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042DeleteWckey(ctx context.Context, id string) SlurmdbAPISlurmdbV0042DeleteWckeyRequest {
	return SlurmdbAPISlurmdbV0042DeleteWckeyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V0042OpenapiWckeyRemovedResp
func (a *SlurmdbAPIService) SlurmdbV0042DeleteWckeyExecute(r SlurmdbAPISlurmdbV0042DeleteWckeyRequest) (*V0042OpenapiWckeyRemovedResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiWckeyRemovedResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042DeleteWckey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/wckey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiWckeyRemovedResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetAccountRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	accountName string
	withAssocs *string
	withCoords *string
	withDeleted *string
}

// Include associations
func (r SlurmdbAPISlurmdbV0042GetAccountRequest) WithAssocs(withAssocs string) SlurmdbAPISlurmdbV0042GetAccountRequest {
	r.withAssocs = &withAssocs
	return r
}

// Include coordinators
func (r SlurmdbAPISlurmdbV0042GetAccountRequest) WithCoords(withCoords string) SlurmdbAPISlurmdbV0042GetAccountRequest {
	r.withCoords = &withCoords
	return r
}

// Include deleted
func (r SlurmdbAPISlurmdbV0042GetAccountRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0042GetAccountRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAccountRequest) Execute() (*V0042OpenapiAccountsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetAccountExecute(r)
}

/*
SlurmdbV0042GetAccount Get account info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountName Account name
 @return SlurmdbAPISlurmdbV0042GetAccountRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetAccount(ctx context.Context, accountName string) SlurmdbAPISlurmdbV0042GetAccountRequest {
	return SlurmdbAPISlurmdbV0042GetAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountName: accountName,
	}
}

// Execute executes the request
//  @return V0042OpenapiAccountsResp
func (a *SlurmdbAPIService) SlurmdbV0042GetAccountExecute(r SlurmdbAPISlurmdbV0042GetAccountRequest) (*V0042OpenapiAccountsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiAccountsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/account/{account_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_name"+"}", url.PathEscape(parameterValueToString(r.accountName, "accountName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "form", "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiAccountsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetAccountsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	description *string
	dELETED *string
	withAssociations *string
	withCoordinators *string
	noUsersAreCoords *string
	usersAreCoords *string
}

// CSV description list
func (r SlurmdbAPISlurmdbV0042GetAccountsRequest) Description(description string) SlurmdbAPISlurmdbV0042GetAccountsRequest {
	r.description = &description
	return r
}

// include deleted associations
func (r SlurmdbAPISlurmdbV0042GetAccountsRequest) DELETED(dELETED string) SlurmdbAPISlurmdbV0042GetAccountsRequest {
	r.dELETED = &dELETED
	return r
}

// query includes associations
func (r SlurmdbAPISlurmdbV0042GetAccountsRequest) WithAssociations(withAssociations string) SlurmdbAPISlurmdbV0042GetAccountsRequest {
	r.withAssociations = &withAssociations
	return r
}

// query includes coordinators
func (r SlurmdbAPISlurmdbV0042GetAccountsRequest) WithCoordinators(withCoordinators string) SlurmdbAPISlurmdbV0042GetAccountsRequest {
	r.withCoordinators = &withCoordinators
	return r
}

// remove users as coordinators
func (r SlurmdbAPISlurmdbV0042GetAccountsRequest) NoUsersAreCoords(noUsersAreCoords string) SlurmdbAPISlurmdbV0042GetAccountsRequest {
	r.noUsersAreCoords = &noUsersAreCoords
	return r
}

// users are coordinators
func (r SlurmdbAPISlurmdbV0042GetAccountsRequest) UsersAreCoords(usersAreCoords string) SlurmdbAPISlurmdbV0042GetAccountsRequest {
	r.usersAreCoords = &usersAreCoords
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAccountsRequest) Execute() (*V0042OpenapiAccountsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetAccountsExecute(r)
}

/*
SlurmdbV0042GetAccounts Get account list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042GetAccountsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetAccounts(ctx context.Context) SlurmdbAPISlurmdbV0042GetAccountsRequest {
	return SlurmdbAPISlurmdbV0042GetAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiAccountsResp
func (a *SlurmdbAPIService) SlurmdbV0042GetAccountsExecute(r SlurmdbAPISlurmdbV0042GetAccountsRequest) (*V0042OpenapiAccountsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiAccountsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/accounts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.dELETED != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "DELETED", r.dELETED, "form", "")
	}
	if r.withAssociations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "WithAssociations", r.withAssociations, "form", "")
	}
	if r.withCoordinators != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "WithCoordinators", r.withCoordinators, "form", "")
	}
	if r.noUsersAreCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "NoUsersAreCoords", r.noUsersAreCoords, "form", "")
	}
	if r.usersAreCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "UsersAreCoords", r.usersAreCoords, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiAccountsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetAssociationRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	cluster *string
	defaultQos *string
	includeDeletedAssociations *string
	includeUsage *string
	filterToOnlyDefaults *string
	includeTheRawQOSOrDeltaQos *string
	includeSubAcctInformation *string
	excludeParentIdName *string
	excludeLimitsFromParents *string
	format *string
	id *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
}

// CSV accounts list
func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) Account(account string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) DefaultQos(defaultQos string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.defaultQos = &defaultQos
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) IncludeDeletedAssociations(includeDeletedAssociations string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.includeDeletedAssociations = &includeDeletedAssociations
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) IncludeUsage(includeUsage string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.includeUsage = &includeUsage
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) FilterToOnlyDefaults(filterToOnlyDefaults string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.filterToOnlyDefaults = &filterToOnlyDefaults
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) IncludeTheRawQOSOrDeltaQos(includeTheRawQOSOrDeltaQos string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.includeTheRawQOSOrDeltaQos = &includeTheRawQOSOrDeltaQos
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) IncludeSubAcctInformation(includeSubAcctInformation string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.includeSubAcctInformation = &includeSubAcctInformation
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) ExcludeParentIdName(excludeParentIdName string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.excludeParentIdName = &excludeParentIdName
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) ExcludeLimitsFromParents(excludeLimitsFromParents string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.excludeLimitsFromParents = &excludeLimitsFromParents
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) Format(format string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.format = &format
	return r
}

// CSV ID list
func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) Id(id string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.id = &id
	return r
}

// CSV names of parent account
func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) ParentAccount(parentAccount string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) Partition(partition string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) Qos(qos string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) User(user string) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	r.user = &user
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationRequest) Execute() (*V0042OpenapiAssocsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetAssociationExecute(r)
}

/*
SlurmdbV0042GetAssociation Get association info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042GetAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetAssociation(ctx context.Context) SlurmdbAPISlurmdbV0042GetAssociationRequest {
	return SlurmdbAPISlurmdbV0042GetAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiAssocsResp
func (a *SlurmdbAPIService) SlurmdbV0042GetAssociationExecute(r SlurmdbAPISlurmdbV0042GetAssociationRequest) (*V0042OpenapiAssocsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiAssocsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.includeDeletedAssociations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include deleted associations", r.includeDeletedAssociations, "form", "")
	}
	if r.includeUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include usage", r.includeUsage, "form", "")
	}
	if r.filterToOnlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filter to only defaults", r.filterToOnlyDefaults, "form", "")
	}
	if r.includeTheRawQOSOrDeltaQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include the raw QOS or delta_qos", r.includeTheRawQOSOrDeltaQos, "form", "")
	}
	if r.includeSubAcctInformation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include sub acct information", r.includeSubAcctInformation, "form", "")
	}
	if r.excludeParentIdName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Exclude parent id/name", r.excludeParentIdName, "form", "")
	}
	if r.excludeLimitsFromParents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Exclude limits from parents", r.excludeLimitsFromParents, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiAssocsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetAssociationsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	cluster *string
	defaultQos *string
	includeDeletedAssociations *string
	includeUsage *string
	filterToOnlyDefaults *string
	includeTheRawQOSOrDeltaQos *string
	includeSubAcctInformation *string
	excludeParentIdName *string
	excludeLimitsFromParents *string
	format *string
	id *string
	parentAccount *string
	partition *string
	qos *string
	usageEnd *string
	usageStart *string
	user *string
}

// CSV accounts list
func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) Account(account string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.account = &account
	return r
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.cluster = &cluster
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) DefaultQos(defaultQos string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.defaultQos = &defaultQos
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) IncludeDeletedAssociations(includeDeletedAssociations string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.includeDeletedAssociations = &includeDeletedAssociations
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) IncludeUsage(includeUsage string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.includeUsage = &includeUsage
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) FilterToOnlyDefaults(filterToOnlyDefaults string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.filterToOnlyDefaults = &filterToOnlyDefaults
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) IncludeTheRawQOSOrDeltaQos(includeTheRawQOSOrDeltaQos string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.includeTheRawQOSOrDeltaQos = &includeTheRawQOSOrDeltaQos
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) IncludeSubAcctInformation(includeSubAcctInformation string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.includeSubAcctInformation = &includeSubAcctInformation
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) ExcludeParentIdName(excludeParentIdName string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.excludeParentIdName = &excludeParentIdName
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) ExcludeLimitsFromParents(excludeLimitsFromParents string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.excludeLimitsFromParents = &excludeLimitsFromParents
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) Format(format string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.format = &format
	return r
}

// CSV ID list
func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) Id(id string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.id = &id
	return r
}

// CSV names of parent account
func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) ParentAccount(parentAccount string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.parentAccount = &parentAccount
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) Partition(partition string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.partition = &partition
	return r
}

// CSV QOS list
func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) Qos(qos string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.qos = &qos
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) User(user string) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	r.user = &user
	return r
}

func (r SlurmdbAPISlurmdbV0042GetAssociationsRequest) Execute() (*V0042OpenapiAssocsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetAssociationsExecute(r)
}

/*
SlurmdbV0042GetAssociations Get association list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042GetAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetAssociations(ctx context.Context) SlurmdbAPISlurmdbV0042GetAssociationsRequest {
	return SlurmdbAPISlurmdbV0042GetAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiAssocsResp
func (a *SlurmdbAPIService) SlurmdbV0042GetAssociationsExecute(r SlurmdbAPISlurmdbV0042GetAssociationsRequest) (*V0042OpenapiAssocsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiAssocsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.defaultQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_qos", r.defaultQos, "form", "")
	}
	if r.includeDeletedAssociations != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include deleted associations", r.includeDeletedAssociations, "form", "")
	}
	if r.includeUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include usage", r.includeUsage, "form", "")
	}
	if r.filterToOnlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Filter to only defaults", r.filterToOnlyDefaults, "form", "")
	}
	if r.includeTheRawQOSOrDeltaQos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include the raw QOS or delta_qos", r.includeTheRawQOSOrDeltaQos, "form", "")
	}
	if r.includeSubAcctInformation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include sub acct information", r.includeSubAcctInformation, "form", "")
	}
	if r.excludeParentIdName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Exclude parent id/name", r.excludeParentIdName, "form", "")
	}
	if r.excludeLimitsFromParents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Exclude limits from parents", r.excludeLimitsFromParents, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.parentAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parent_account", r.parentAccount, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiAssocsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetClusterRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	clusterName string
	classification *string
	cluster *string
	federation *string
	flags *string
	format *string
	rpcVersion *string
	usageEnd *string
	usageStart *string
	withDeleted *string
	withUsage *string
}

// Type of machine
func (r SlurmdbAPISlurmdbV0042GetClusterRequest) Classification(classification string) SlurmdbAPISlurmdbV0042GetClusterRequest {
	r.classification = &classification
	return r
}

// CSV cluster list
func (r SlurmdbAPISlurmdbV0042GetClusterRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0042GetClusterRequest {
	r.cluster = &cluster
	return r
}

// CSV federation list
func (r SlurmdbAPISlurmdbV0042GetClusterRequest) Federation(federation string) SlurmdbAPISlurmdbV0042GetClusterRequest {
	r.federation = &federation
	return r
}

// Query flags
func (r SlurmdbAPISlurmdbV0042GetClusterRequest) Flags(flags string) SlurmdbAPISlurmdbV0042GetClusterRequest {
	r.flags = &flags
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0042GetClusterRequest) Format(format string) SlurmdbAPISlurmdbV0042GetClusterRequest {
	r.format = &format
	return r
}

// CSV RPC version list
func (r SlurmdbAPISlurmdbV0042GetClusterRequest) RpcVersion(rpcVersion string) SlurmdbAPISlurmdbV0042GetClusterRequest {
	r.rpcVersion = &rpcVersion
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetClusterRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0042GetClusterRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetClusterRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0042GetClusterRequest {
	r.usageStart = &usageStart
	return r
}

// Include deleted clusters
func (r SlurmdbAPISlurmdbV0042GetClusterRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0042GetClusterRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0042GetClusterRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0042GetClusterRequest {
	r.withUsage = &withUsage
	return r
}

func (r SlurmdbAPISlurmdbV0042GetClusterRequest) Execute() (*V0042OpenapiClustersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetClusterExecute(r)
}

/*
SlurmdbV0042GetCluster Get cluster info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clusterName Cluster name
 @return SlurmdbAPISlurmdbV0042GetClusterRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetCluster(ctx context.Context, clusterName string) SlurmdbAPISlurmdbV0042GetClusterRequest {
	return SlurmdbAPISlurmdbV0042GetClusterRequest{
		ApiService: a,
		ctx: ctx,
		clusterName: clusterName,
	}
}

// Execute executes the request
//  @return V0042OpenapiClustersResp
func (a *SlurmdbAPIService) SlurmdbV0042GetClusterExecute(r SlurmdbAPISlurmdbV0042GetClusterRequest) (*V0042OpenapiClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/cluster/{cluster_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"cluster_name"+"}", url.PathEscape(parameterValueToString(r.clusterName, "clusterName")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.classification != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classification", r.classification, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.federation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "federation", r.federation, "form", "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.rpcVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rpc_version", r.rpcVersion, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiClustersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetClustersRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	updateTime *string
}

// Query reservations updated more recently than this time (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetClustersRequest) UpdateTime(updateTime string) SlurmdbAPISlurmdbV0042GetClustersRequest {
	r.updateTime = &updateTime
	return r
}

func (r SlurmdbAPISlurmdbV0042GetClustersRequest) Execute() (*V0042OpenapiClustersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetClustersExecute(r)
}

/*
SlurmdbV0042GetClusters Get cluster list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042GetClustersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetClusters(ctx context.Context) SlurmdbAPISlurmdbV0042GetClustersRequest {
	return SlurmdbAPISlurmdbV0042GetClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiClustersResp
func (a *SlurmdbAPIService) SlurmdbV0042GetClustersExecute(r SlurmdbAPISlurmdbV0042GetClustersRequest) (*V0042OpenapiClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiClustersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetConfigRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
}

func (r SlurmdbAPISlurmdbV0042GetConfigRequest) Execute() (*V0042OpenapiSlurmdbdConfigResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetConfigExecute(r)
}

/*
SlurmdbV0042GetConfig Dump all configuration information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042GetConfigRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetConfig(ctx context.Context) SlurmdbAPISlurmdbV0042GetConfigRequest {
	return SlurmdbAPISlurmdbV0042GetConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiSlurmdbdConfigResp
func (a *SlurmdbAPIService) SlurmdbV0042GetConfigExecute(r SlurmdbAPISlurmdbV0042GetConfigRequest) (*V0042OpenapiSlurmdbdConfigResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiSlurmdbdConfigResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiSlurmdbdConfigResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetDiagRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
}

func (r SlurmdbAPISlurmdbV0042GetDiagRequest) Execute() (*V0042OpenapiSlurmdbdStatsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetDiagExecute(r)
}

/*
SlurmdbV0042GetDiag Get slurmdb diagnostics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042GetDiagRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetDiag(ctx context.Context) SlurmdbAPISlurmdbV0042GetDiagRequest {
	return SlurmdbAPISlurmdbV0042GetDiagRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiSlurmdbdStatsResp
func (a *SlurmdbAPIService) SlurmdbV0042GetDiagExecute(r SlurmdbAPISlurmdbV0042GetDiagRequest) (*V0042OpenapiSlurmdbdStatsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiSlurmdbdStatsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetDiag")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/diag/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiSlurmdbdStatsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetInstanceRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	cluster *string
	extra *string
	format *string
	instanceId *string
	instanceType *string
	nodeList *string
	timeEnd *string
	timeStart *string
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0042GetInstanceRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0042GetInstanceRequest {
	r.cluster = &cluster
	return r
}

// CSV extra list
func (r SlurmdbAPISlurmdbV0042GetInstanceRequest) Extra(extra string) SlurmdbAPISlurmdbV0042GetInstanceRequest {
	r.extra = &extra
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0042GetInstanceRequest) Format(format string) SlurmdbAPISlurmdbV0042GetInstanceRequest {
	r.format = &format
	return r
}

// CSV instance_id list
func (r SlurmdbAPISlurmdbV0042GetInstanceRequest) InstanceId(instanceId string) SlurmdbAPISlurmdbV0042GetInstanceRequest {
	r.instanceId = &instanceId
	return r
}

// CSV instance_type list
func (r SlurmdbAPISlurmdbV0042GetInstanceRequest) InstanceType(instanceType string) SlurmdbAPISlurmdbV0042GetInstanceRequest {
	r.instanceType = &instanceType
	return r
}

// Ranged node string
func (r SlurmdbAPISlurmdbV0042GetInstanceRequest) NodeList(nodeList string) SlurmdbAPISlurmdbV0042GetInstanceRequest {
	r.nodeList = &nodeList
	return r
}

// Time end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetInstanceRequest) TimeEnd(timeEnd string) SlurmdbAPISlurmdbV0042GetInstanceRequest {
	r.timeEnd = &timeEnd
	return r
}

// Time start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetInstanceRequest) TimeStart(timeStart string) SlurmdbAPISlurmdbV0042GetInstanceRequest {
	r.timeStart = &timeStart
	return r
}

func (r SlurmdbAPISlurmdbV0042GetInstanceRequest) Execute() (*V0042OpenapiInstancesResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetInstanceExecute(r)
}

/*
SlurmdbV0042GetInstance Get instance info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042GetInstanceRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetInstance(ctx context.Context) SlurmdbAPISlurmdbV0042GetInstanceRequest {
	return SlurmdbAPISlurmdbV0042GetInstanceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiInstancesResp
func (a *SlurmdbAPIService) SlurmdbV0042GetInstanceExecute(r SlurmdbAPISlurmdbV0042GetInstanceRequest) (*V0042OpenapiInstancesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiInstancesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetInstance")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/instance/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.extra != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extra", r.extra, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "form", "")
	}
	if r.instanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_type", r.instanceType, "form", "")
	}
	if r.nodeList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_list", r.nodeList, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiInstancesResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetInstancesRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	cluster *string
	extra *string
	format *string
	instanceId *string
	instanceType *string
	nodeList *string
	timeEnd *string
	timeStart *string
}

// CSV clusters list
func (r SlurmdbAPISlurmdbV0042GetInstancesRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0042GetInstancesRequest {
	r.cluster = &cluster
	return r
}

// CSV extra list
func (r SlurmdbAPISlurmdbV0042GetInstancesRequest) Extra(extra string) SlurmdbAPISlurmdbV0042GetInstancesRequest {
	r.extra = &extra
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0042GetInstancesRequest) Format(format string) SlurmdbAPISlurmdbV0042GetInstancesRequest {
	r.format = &format
	return r
}

// CSV instance_id list
func (r SlurmdbAPISlurmdbV0042GetInstancesRequest) InstanceId(instanceId string) SlurmdbAPISlurmdbV0042GetInstancesRequest {
	r.instanceId = &instanceId
	return r
}

// CSV instance_type list
func (r SlurmdbAPISlurmdbV0042GetInstancesRequest) InstanceType(instanceType string) SlurmdbAPISlurmdbV0042GetInstancesRequest {
	r.instanceType = &instanceType
	return r
}

// Ranged node string
func (r SlurmdbAPISlurmdbV0042GetInstancesRequest) NodeList(nodeList string) SlurmdbAPISlurmdbV0042GetInstancesRequest {
	r.nodeList = &nodeList
	return r
}

// Time end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetInstancesRequest) TimeEnd(timeEnd string) SlurmdbAPISlurmdbV0042GetInstancesRequest {
	r.timeEnd = &timeEnd
	return r
}

// Time start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetInstancesRequest) TimeStart(timeStart string) SlurmdbAPISlurmdbV0042GetInstancesRequest {
	r.timeStart = &timeStart
	return r
}

func (r SlurmdbAPISlurmdbV0042GetInstancesRequest) Execute() (*V0042OpenapiInstancesResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetInstancesExecute(r)
}

/*
SlurmdbV0042GetInstances Get instance list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042GetInstancesRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetInstances(ctx context.Context) SlurmdbAPISlurmdbV0042GetInstancesRequest {
	return SlurmdbAPISlurmdbV0042GetInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiInstancesResp
func (a *SlurmdbAPIService) SlurmdbV0042GetInstancesExecute(r SlurmdbAPISlurmdbV0042GetInstancesRequest) (*V0042OpenapiInstancesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiInstancesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/instances/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.extra != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "extra", r.extra, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_id", r.instanceId, "form", "")
	}
	if r.instanceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instance_type", r.instanceType, "form", "")
	}
	if r.nodeList != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node_list", r.nodeList, "form", "")
	}
	if r.timeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_end", r.timeEnd, "form", "")
	}
	if r.timeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_start", r.timeStart, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiInstancesResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetJobRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	jobId string
}

func (r SlurmdbAPISlurmdbV0042GetJobRequest) Execute() (*V0042OpenapiSlurmdbdJobsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetJobExecute(r)
}

/*
SlurmdbV0042GetJob Get job info

This endpoint may return multiple job entries since job_id is not a unique key - only the tuple (cluster, job_id, start_time) is unique. If the requested job_id is a component of a heterogeneous job all components are returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param jobId Job ID
 @return SlurmdbAPISlurmdbV0042GetJobRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetJob(ctx context.Context, jobId string) SlurmdbAPISlurmdbV0042GetJobRequest {
	return SlurmdbAPISlurmdbV0042GetJobRequest{
		ApiService: a,
		ctx: ctx,
		jobId: jobId,
	}
}

// Execute executes the request
//  @return V0042OpenapiSlurmdbdJobsResp
func (a *SlurmdbAPIService) SlurmdbV0042GetJobExecute(r SlurmdbAPISlurmdbV0042GetJobRequest) (*V0042OpenapiSlurmdbdJobsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiSlurmdbdJobsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetJob")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/job/{job_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"job_id"+"}", url.PathEscape(parameterValueToString(r.jobId, "jobId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiSlurmdbdJobsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetJobsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	account *string
	association *string
	cluster *string
	constraints *string
	schedulerUnset *string
	scheduledOnSubmit *string
	scheduledByMain *string
	scheduledByBackfill *string
	jobStarted *string
	exitCode *string
	showDuplicates *string
	skipSteps *string
	disableTruncateUsageTime *string
	wholeHetjob *string
	disableWholeHetjob *string
	disableWaitForResult *string
	usageTimeAsSubmitTime *string
	showBatchScript *string
	showJobEnvironment *string
	format *string
	groups *string
	jobName *string
	partition *string
	qos *string
	reason *string
	reservation *string
	reservationId *string
	state *string
	step *string
	endTime *string
	startTime *string
	node *string
	users *string
	wckey *string
}

// CSV account list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Account(account string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.account = &account
	return r
}

// CSV association list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Association(association string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.association = &association
	return r
}

// CSV cluster list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.cluster = &cluster
	return r
}

// CSV constraint list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Constraints(constraints string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.constraints = &constraints
	return r
}

// Schedule bits not set
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) SchedulerUnset(schedulerUnset string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.schedulerUnset = &schedulerUnset
	return r
}

// Job was started on submit
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) ScheduledOnSubmit(scheduledOnSubmit string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.scheduledOnSubmit = &scheduledOnSubmit
	return r
}

// Job was started from main scheduler
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) ScheduledByMain(scheduledByMain string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.scheduledByMain = &scheduledByMain
	return r
}

// Job was started from backfill
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) ScheduledByBackfill(scheduledByBackfill string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.scheduledByBackfill = &scheduledByBackfill
	return r
}

// Job start RPC was received
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) JobStarted(jobStarted string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.jobStarted = &jobStarted
	return r
}

// Job exit code (numeric)
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) ExitCode(exitCode string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.exitCode = &exitCode
	return r
}

// Include duplicate job entries
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) ShowDuplicates(showDuplicates string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.showDuplicates = &showDuplicates
	return r
}

// Exclude job step details
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) SkipSteps(skipSteps string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.skipSteps = &skipSteps
	return r
}

// Do not truncate the time to usage_start and usage_end
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) DisableTruncateUsageTime(disableTruncateUsageTime string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.disableTruncateUsageTime = &disableTruncateUsageTime
	return r
}

// Include details on all hetjob components
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) WholeHetjob(wholeHetjob string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.wholeHetjob = &wholeHetjob
	return r
}

// Only show details on specified hetjob components
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) DisableWholeHetjob(disableWholeHetjob string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.disableWholeHetjob = &disableWholeHetjob
	return r
}

// Tell dbd not to wait for the result
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) DisableWaitForResult(disableWaitForResult string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.disableWaitForResult = &disableWaitForResult
	return r
}

// Use usage_time as the submit_time of the job
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) UsageTimeAsSubmitTime(usageTimeAsSubmitTime string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.usageTimeAsSubmitTime = &usageTimeAsSubmitTime
	return r
}

// Include job script
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) ShowBatchScript(showBatchScript string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.showBatchScript = &showBatchScript
	return r
}

// Include job environment
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) ShowJobEnvironment(showJobEnvironment string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.showJobEnvironment = &showJobEnvironment
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Format(format string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.format = &format
	return r
}

// CSV group list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Groups(groups string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.groups = &groups
	return r
}

// CSV job name list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) JobName(jobName string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.jobName = &jobName
	return r
}

// CSV partition name list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Partition(partition string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.partition = &partition
	return r
}

// CSV QOS name list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Qos(qos string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.qos = &qos
	return r
}

// CSV reason list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Reason(reason string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.reason = &reason
	return r
}

// CSV reservation name list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Reservation(reservation string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.reservation = &reservation
	return r
}

// CSV reservation ID list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) ReservationId(reservationId string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.reservationId = &reservationId
	return r
}

// CSV state list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) State(state string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.state = &state
	return r
}

// CSV step id list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Step(step string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.step = &step
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) EndTime(endTime string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.endTime = &endTime
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) StartTime(startTime string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.startTime = &startTime
	return r
}

// Ranged node string where jobs ran
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Node(node string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.node = &node
	return r
}

// CSV user name list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Users(users string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.users = &users
	return r
}

// CSV WCKey list
func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Wckey(wckey string) SlurmdbAPISlurmdbV0042GetJobsRequest {
	r.wckey = &wckey
	return r
}

func (r SlurmdbAPISlurmdbV0042GetJobsRequest) Execute() (*V0042OpenapiSlurmdbdJobsResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetJobsExecute(r)
}

/*
SlurmdbV0042GetJobs Get job list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042GetJobsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetJobs(ctx context.Context) SlurmdbAPISlurmdbV0042GetJobsRequest {
	return SlurmdbAPISlurmdbV0042GetJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiSlurmdbdJobsResp
func (a *SlurmdbAPIService) SlurmdbV0042GetJobsExecute(r SlurmdbAPISlurmdbV0042GetJobsRequest) (*V0042OpenapiSlurmdbdJobsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiSlurmdbdJobsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/jobs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.account != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account", r.account, "form", "")
	}
	if r.association != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "association", r.association, "form", "")
	}
	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.constraints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "constraints", r.constraints, "form", "")
	}
	if r.schedulerUnset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduler_unset", r.schedulerUnset, "form", "")
	}
	if r.scheduledOnSubmit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_on_submit", r.scheduledOnSubmit, "form", "")
	}
	if r.scheduledByMain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_by_main", r.scheduledByMain, "form", "")
	}
	if r.scheduledByBackfill != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scheduled_by_backfill", r.scheduledByBackfill, "form", "")
	}
	if r.jobStarted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_started", r.jobStarted, "form", "")
	}
	if r.exitCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exit_code", r.exitCode, "form", "")
	}
	if r.showDuplicates != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_duplicates", r.showDuplicates, "form", "")
	}
	if r.skipSteps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skip_steps", r.skipSteps, "form", "")
	}
	if r.disableTruncateUsageTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_truncate_usage_time", r.disableTruncateUsageTime, "form", "")
	}
	if r.wholeHetjob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "whole_hetjob", r.wholeHetjob, "form", "")
	}
	if r.disableWholeHetjob != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_whole_hetjob", r.disableWholeHetjob, "form", "")
	}
	if r.disableWaitForResult != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disable_wait_for_result", r.disableWaitForResult, "form", "")
	}
	if r.usageTimeAsSubmitTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_time_as_submit_time", r.usageTimeAsSubmitTime, "form", "")
	}
	if r.showBatchScript != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_batch_script", r.showBatchScript, "form", "")
	}
	if r.showJobEnvironment != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "show_job_environment", r.showJobEnvironment, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.groups != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groups", r.groups, "form", "")
	}
	if r.jobName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "job_name", r.jobName, "form", "")
	}
	if r.partition != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partition", r.partition, "form", "")
	}
	if r.qos != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "qos", r.qos, "form", "")
	}
	if r.reason != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reason", r.reason, "form", "")
	}
	if r.reservation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservation", r.reservation, "form", "")
	}
	if r.reservationId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reservation_id", r.reservationId, "form", "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "form", "")
	}
	if r.step != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "step", r.step, "form", "")
	}
	if r.endTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end_time", r.endTime, "form", "")
	}
	if r.startTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_time", r.startTime, "form", "")
	}
	if r.node != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "node", r.node, "form", "")
	}
	if r.users != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "users", r.users, "form", "")
	}
	if r.wckey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "wckey", r.wckey, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiSlurmdbdJobsResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetPingRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
}

func (r SlurmdbAPISlurmdbV0042GetPingRequest) Execute() (*V0042OpenapiSlurmdbdPingResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetPingExecute(r)
}

/*
SlurmdbV0042GetPing ping test

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042GetPingRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetPing(ctx context.Context) SlurmdbAPISlurmdbV0042GetPingRequest {
	return SlurmdbAPISlurmdbV0042GetPingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiSlurmdbdPingResp
func (a *SlurmdbAPIService) SlurmdbV0042GetPingExecute(r SlurmdbAPISlurmdbV0042GetPingRequest) (*V0042OpenapiSlurmdbdPingResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiSlurmdbdPingResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetPing")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/ping/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiSlurmdbdPingResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetQosRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	description *string
	includeDeletedQOS *string
	id *string
	format *string
	name *string
	preemptMode *string
}

// CSV description list
func (r SlurmdbAPISlurmdbV0042GetQosRequest) Description(description string) SlurmdbAPISlurmdbV0042GetQosRequest {
	r.description = &description
	return r
}

func (r SlurmdbAPISlurmdbV0042GetQosRequest) IncludeDeletedQOS(includeDeletedQOS string) SlurmdbAPISlurmdbV0042GetQosRequest {
	r.includeDeletedQOS = &includeDeletedQOS
	return r
}

// CSV QOS id list
func (r SlurmdbAPISlurmdbV0042GetQosRequest) Id(id string) SlurmdbAPISlurmdbV0042GetQosRequest {
	r.id = &id
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0042GetQosRequest) Format(format string) SlurmdbAPISlurmdbV0042GetQosRequest {
	r.format = &format
	return r
}

// CSV QOS name list
func (r SlurmdbAPISlurmdbV0042GetQosRequest) Name(name string) SlurmdbAPISlurmdbV0042GetQosRequest {
	r.name = &name
	return r
}

// PreemptMode used when jobs in this QOS are preempted
func (r SlurmdbAPISlurmdbV0042GetQosRequest) PreemptMode(preemptMode string) SlurmdbAPISlurmdbV0042GetQosRequest {
	r.preemptMode = &preemptMode
	return r
}

func (r SlurmdbAPISlurmdbV0042GetQosRequest) Execute() (*V0042OpenapiSlurmdbdQosResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetQosExecute(r)
}

/*
SlurmdbV0042GetQos Get QOS list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042GetQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetQos(ctx context.Context) SlurmdbAPISlurmdbV0042GetQosRequest {
	return SlurmdbAPISlurmdbV0042GetQosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiSlurmdbdQosResp
func (a *SlurmdbAPIService) SlurmdbV0042GetQosExecute(r SlurmdbAPISlurmdbV0042GetQosRequest) (*V0042OpenapiSlurmdbdQosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiSlurmdbdQosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/qos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.includeDeletedQOS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include deleted QOS", r.includeDeletedQOS, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.preemptMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preempt_mode", r.preemptMode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiSlurmdbdQosResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetSingleQosRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	qos string
	withDeleted *string
}

// Query includes deleted QOS
func (r SlurmdbAPISlurmdbV0042GetSingleQosRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0042GetSingleQosRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r SlurmdbAPISlurmdbV0042GetSingleQosRequest) Execute() (*V0042OpenapiSlurmdbdQosResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetSingleQosExecute(r)
}

/*
SlurmdbV0042GetSingleQos Get QOS info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param qos QOS name
 @return SlurmdbAPISlurmdbV0042GetSingleQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetSingleQos(ctx context.Context, qos string) SlurmdbAPISlurmdbV0042GetSingleQosRequest {
	return SlurmdbAPISlurmdbV0042GetSingleQosRequest{
		ApiService: a,
		ctx: ctx,
		qos: qos,
	}
}

// Execute executes the request
//  @return V0042OpenapiSlurmdbdQosResp
func (a *SlurmdbAPIService) SlurmdbV0042GetSingleQosExecute(r SlurmdbAPISlurmdbV0042GetSingleQosRequest) (*V0042OpenapiSlurmdbdQosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiSlurmdbdQosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetSingleQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/qos/{qos}"
	localVarPath = strings.Replace(localVarPath, "{"+"qos"+"}", url.PathEscape(parameterValueToString(r.qos, "qos")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiSlurmdbdQosResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetTresRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
}

func (r SlurmdbAPISlurmdbV0042GetTresRequest) Execute() (*V0042OpenapiTresResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetTresExecute(r)
}

/*
SlurmdbV0042GetTres Get TRES info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042GetTresRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetTres(ctx context.Context) SlurmdbAPISlurmdbV0042GetTresRequest {
	return SlurmdbAPISlurmdbV0042GetTresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiTresResp
func (a *SlurmdbAPIService) SlurmdbV0042GetTresExecute(r SlurmdbAPISlurmdbV0042GetTresRequest) (*V0042OpenapiTresResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiTresResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetTres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/tres/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiTresResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetUserRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	name string
	withDeleted *string
	withAssocs *string
	withCoords *string
	withWckeys *string
}

// Include deleted users
func (r SlurmdbAPISlurmdbV0042GetUserRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0042GetUserRequest {
	r.withDeleted = &withDeleted
	return r
}

// Include associations
func (r SlurmdbAPISlurmdbV0042GetUserRequest) WithAssocs(withAssocs string) SlurmdbAPISlurmdbV0042GetUserRequest {
	r.withAssocs = &withAssocs
	return r
}

// Include coordinators
func (r SlurmdbAPISlurmdbV0042GetUserRequest) WithCoords(withCoords string) SlurmdbAPISlurmdbV0042GetUserRequest {
	r.withCoords = &withCoords
	return r
}

// Include WCKeys
func (r SlurmdbAPISlurmdbV0042GetUserRequest) WithWckeys(withWckeys string) SlurmdbAPISlurmdbV0042GetUserRequest {
	r.withWckeys = &withWckeys
	return r
}

func (r SlurmdbAPISlurmdbV0042GetUserRequest) Execute() (*V0042OpenapiUsersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetUserExecute(r)
}

/*
SlurmdbV0042GetUser Get user info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name User name
 @return SlurmdbAPISlurmdbV0042GetUserRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetUser(ctx context.Context, name string) SlurmdbAPISlurmdbV0042GetUserRequest {
	return SlurmdbAPISlurmdbV0042GetUserRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return V0042OpenapiUsersResp
func (a *SlurmdbAPIService) SlurmdbV0042GetUserExecute(r SlurmdbAPISlurmdbV0042GetUserRequest) (*V0042OpenapiUsersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiUsersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetUser")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/user/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "form", "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "form", "")
	}
	if r.withWckeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_wckeys", r.withWckeys, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiUsersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetUsersRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	adminLevel *string
	defaultAccount *string
	defaultWckey *string
	withAssocs *string
	withCoords *string
	withDeleted *string
	withWckeys *string
	withoutDefaults *string
}

// Administrator level
func (r SlurmdbAPISlurmdbV0042GetUsersRequest) AdminLevel(adminLevel string) SlurmdbAPISlurmdbV0042GetUsersRequest {
	r.adminLevel = &adminLevel
	return r
}

// CSV default account list
func (r SlurmdbAPISlurmdbV0042GetUsersRequest) DefaultAccount(defaultAccount string) SlurmdbAPISlurmdbV0042GetUsersRequest {
	r.defaultAccount = &defaultAccount
	return r
}

// CSV default WCKey list
func (r SlurmdbAPISlurmdbV0042GetUsersRequest) DefaultWckey(defaultWckey string) SlurmdbAPISlurmdbV0042GetUsersRequest {
	r.defaultWckey = &defaultWckey
	return r
}

// With associations
func (r SlurmdbAPISlurmdbV0042GetUsersRequest) WithAssocs(withAssocs string) SlurmdbAPISlurmdbV0042GetUsersRequest {
	r.withAssocs = &withAssocs
	return r
}

// With coordinators
func (r SlurmdbAPISlurmdbV0042GetUsersRequest) WithCoords(withCoords string) SlurmdbAPISlurmdbV0042GetUsersRequest {
	r.withCoords = &withCoords
	return r
}

// With deleted
func (r SlurmdbAPISlurmdbV0042GetUsersRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0042GetUsersRequest {
	r.withDeleted = &withDeleted
	return r
}

// With WCKeys
func (r SlurmdbAPISlurmdbV0042GetUsersRequest) WithWckeys(withWckeys string) SlurmdbAPISlurmdbV0042GetUsersRequest {
	r.withWckeys = &withWckeys
	return r
}

// Exclude defaults
func (r SlurmdbAPISlurmdbV0042GetUsersRequest) WithoutDefaults(withoutDefaults string) SlurmdbAPISlurmdbV0042GetUsersRequest {
	r.withoutDefaults = &withoutDefaults
	return r
}

func (r SlurmdbAPISlurmdbV0042GetUsersRequest) Execute() (*V0042OpenapiUsersResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetUsersExecute(r)
}

/*
SlurmdbV0042GetUsers Get user list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042GetUsersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetUsers(ctx context.Context) SlurmdbAPISlurmdbV0042GetUsersRequest {
	return SlurmdbAPISlurmdbV0042GetUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiUsersResp
func (a *SlurmdbAPIService) SlurmdbV0042GetUsersExecute(r SlurmdbAPISlurmdbV0042GetUsersRequest) (*V0042OpenapiUsersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiUsersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.adminLevel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "admin_level", r.adminLevel, "form", "")
	}
	if r.defaultAccount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_account", r.defaultAccount, "form", "")
	}
	if r.defaultWckey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_wckey", r.defaultWckey, "form", "")
	}
	if r.withAssocs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_assocs", r.withAssocs, "form", "")
	}
	if r.withCoords != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_coords", r.withCoords, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	if r.withWckeys != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_wckeys", r.withWckeys, "form", "")
	}
	if r.withoutDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "without_defaults", r.withoutDefaults, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiUsersResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetWckeyRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	id string
}

func (r SlurmdbAPISlurmdbV0042GetWckeyRequest) Execute() (*V0042OpenapiWckeyResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetWckeyExecute(r)
}

/*
SlurmdbV0042GetWckey Get wckey info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id WCKey ID
 @return SlurmdbAPISlurmdbV0042GetWckeyRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetWckey(ctx context.Context, id string) SlurmdbAPISlurmdbV0042GetWckeyRequest {
	return SlurmdbAPISlurmdbV0042GetWckeyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return V0042OpenapiWckeyResp
func (a *SlurmdbAPIService) SlurmdbV0042GetWckeyExecute(r SlurmdbAPISlurmdbV0042GetWckeyRequest) (*V0042OpenapiWckeyResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiWckeyResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetWckey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/wckey/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiWckeyResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042GetWckeysRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	cluster *string
	format *string
	id *string
	name *string
	onlyDefaults *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
}

// CSV cluster name list
func (r SlurmdbAPISlurmdbV0042GetWckeysRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0042GetWckeysRequest {
	r.cluster = &cluster
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0042GetWckeysRequest) Format(format string) SlurmdbAPISlurmdbV0042GetWckeysRequest {
	r.format = &format
	return r
}

// CSV ID list
func (r SlurmdbAPISlurmdbV0042GetWckeysRequest) Id(id string) SlurmdbAPISlurmdbV0042GetWckeysRequest {
	r.id = &id
	return r
}

// CSV name list
func (r SlurmdbAPISlurmdbV0042GetWckeysRequest) Name(name string) SlurmdbAPISlurmdbV0042GetWckeysRequest {
	r.name = &name
	return r
}

// Only query defaults
func (r SlurmdbAPISlurmdbV0042GetWckeysRequest) OnlyDefaults(onlyDefaults string) SlurmdbAPISlurmdbV0042GetWckeysRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetWckeysRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0042GetWckeysRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042GetWckeysRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0042GetWckeysRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0042GetWckeysRequest) User(user string) SlurmdbAPISlurmdbV0042GetWckeysRequest {
	r.user = &user
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0042GetWckeysRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0042GetWckeysRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted WCKeys
func (r SlurmdbAPISlurmdbV0042GetWckeysRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0042GetWckeysRequest {
	r.withDeleted = &withDeleted
	return r
}

func (r SlurmdbAPISlurmdbV0042GetWckeysRequest) Execute() (*V0042OpenapiWckeyResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042GetWckeysExecute(r)
}

/*
SlurmdbV0042GetWckeys Get wckey list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042GetWckeysRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042GetWckeys(ctx context.Context) SlurmdbAPISlurmdbV0042GetWckeysRequest {
	return SlurmdbAPISlurmdbV0042GetWckeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiWckeyResp
func (a *SlurmdbAPIService) SlurmdbV0042GetWckeysExecute(r SlurmdbAPISlurmdbV0042GetWckeysRequest) (*V0042OpenapiWckeyResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiWckeyResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042GetWckeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/wckeys/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiWckeyResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042PostAccountsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0042OpenapiAccountsResp *V0042OpenapiAccountsResp
}

// Description of accounts to update/create
func (r SlurmdbAPISlurmdbV0042PostAccountsRequest) V0042OpenapiAccountsResp(v0042OpenapiAccountsResp V0042OpenapiAccountsResp) SlurmdbAPISlurmdbV0042PostAccountsRequest {
	r.v0042OpenapiAccountsResp = &v0042OpenapiAccountsResp
	return r
}

func (r SlurmdbAPISlurmdbV0042PostAccountsRequest) Execute() (*V0042OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042PostAccountsExecute(r)
}

/*
SlurmdbV0042PostAccounts Add/update list of accounts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042PostAccountsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042PostAccounts(ctx context.Context) SlurmdbAPISlurmdbV0042PostAccountsRequest {
	return SlurmdbAPISlurmdbV0042PostAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0042PostAccountsExecute(r SlurmdbAPISlurmdbV0042PostAccountsRequest) (*V0042OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042PostAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/accounts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0042OpenapiAccountsResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042PostAccountsAssociationRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0042OpenapiAccountsAddCondResp *V0042OpenapiAccountsAddCondResp
}

// Add list of accounts with conditional association
func (r SlurmdbAPISlurmdbV0042PostAccountsAssociationRequest) V0042OpenapiAccountsAddCondResp(v0042OpenapiAccountsAddCondResp V0042OpenapiAccountsAddCondResp) SlurmdbAPISlurmdbV0042PostAccountsAssociationRequest {
	r.v0042OpenapiAccountsAddCondResp = &v0042OpenapiAccountsAddCondResp
	return r
}

func (r SlurmdbAPISlurmdbV0042PostAccountsAssociationRequest) Execute() (*V0042OpenapiAccountsAddCondRespStr, *http.Response, error) {
	return r.ApiService.SlurmdbV0042PostAccountsAssociationExecute(r)
}

/*
SlurmdbV0042PostAccountsAssociation Add accounts with conditional association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042PostAccountsAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042PostAccountsAssociation(ctx context.Context) SlurmdbAPISlurmdbV0042PostAccountsAssociationRequest {
	return SlurmdbAPISlurmdbV0042PostAccountsAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiAccountsAddCondRespStr
func (a *SlurmdbAPIService) SlurmdbV0042PostAccountsAssociationExecute(r SlurmdbAPISlurmdbV0042PostAccountsAssociationRequest) (*V0042OpenapiAccountsAddCondRespStr, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiAccountsAddCondRespStr
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042PostAccountsAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/accounts_association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0042OpenapiAccountsAddCondResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiAccountsAddCondRespStr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042PostAssociationsRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0042OpenapiAssocsResp *V0042OpenapiAssocsResp
}

// Job description
func (r SlurmdbAPISlurmdbV0042PostAssociationsRequest) V0042OpenapiAssocsResp(v0042OpenapiAssocsResp V0042OpenapiAssocsResp) SlurmdbAPISlurmdbV0042PostAssociationsRequest {
	r.v0042OpenapiAssocsResp = &v0042OpenapiAssocsResp
	return r
}

func (r SlurmdbAPISlurmdbV0042PostAssociationsRequest) Execute() (*V0042OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042PostAssociationsExecute(r)
}

/*
SlurmdbV0042PostAssociations Set associations info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042PostAssociationsRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042PostAssociations(ctx context.Context) SlurmdbAPISlurmdbV0042PostAssociationsRequest {
	return SlurmdbAPISlurmdbV0042PostAssociationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0042PostAssociationsExecute(r SlurmdbAPISlurmdbV0042PostAssociationsRequest) (*V0042OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042PostAssociations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/associations/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0042OpenapiAssocsResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042PostClustersRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	updateTime *string
	v0042OpenapiClustersResp *V0042OpenapiClustersResp
}

// Query reservations updated more recently than this time (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042PostClustersRequest) UpdateTime(updateTime string) SlurmdbAPISlurmdbV0042PostClustersRequest {
	r.updateTime = &updateTime
	return r
}

// Cluster add or update descriptions
func (r SlurmdbAPISlurmdbV0042PostClustersRequest) V0042OpenapiClustersResp(v0042OpenapiClustersResp V0042OpenapiClustersResp) SlurmdbAPISlurmdbV0042PostClustersRequest {
	r.v0042OpenapiClustersResp = &v0042OpenapiClustersResp
	return r
}

func (r SlurmdbAPISlurmdbV0042PostClustersRequest) Execute() (*V0042OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042PostClustersExecute(r)
}

/*
SlurmdbV0042PostClusters Get cluster list

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042PostClustersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042PostClusters(ctx context.Context) SlurmdbAPISlurmdbV0042PostClustersRequest {
	return SlurmdbAPISlurmdbV0042PostClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0042PostClustersExecute(r SlurmdbAPISlurmdbV0042PostClustersRequest) (*V0042OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042PostClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0042OpenapiClustersResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042PostConfigRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0042OpenapiSlurmdbdConfigResp *V0042OpenapiSlurmdbdConfigResp
}

// Add or update config
func (r SlurmdbAPISlurmdbV0042PostConfigRequest) V0042OpenapiSlurmdbdConfigResp(v0042OpenapiSlurmdbdConfigResp V0042OpenapiSlurmdbdConfigResp) SlurmdbAPISlurmdbV0042PostConfigRequest {
	r.v0042OpenapiSlurmdbdConfigResp = &v0042OpenapiSlurmdbdConfigResp
	return r
}

func (r SlurmdbAPISlurmdbV0042PostConfigRequest) Execute() (*V0042OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042PostConfigExecute(r)
}

/*
SlurmdbV0042PostConfig Load all configuration information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042PostConfigRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042PostConfig(ctx context.Context) SlurmdbAPISlurmdbV0042PostConfigRequest {
	return SlurmdbAPISlurmdbV0042PostConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0042PostConfigExecute(r SlurmdbAPISlurmdbV0042PostConfigRequest) (*V0042OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042PostConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0042OpenapiSlurmdbdConfigResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042PostQosRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	description *string
	includeDeletedQOS *string
	id *string
	format *string
	name *string
	preemptMode *string
	v0042OpenapiSlurmdbdQosResp *V0042OpenapiSlurmdbdQosResp
}

// CSV description list
func (r SlurmdbAPISlurmdbV0042PostQosRequest) Description(description string) SlurmdbAPISlurmdbV0042PostQosRequest {
	r.description = &description
	return r
}

func (r SlurmdbAPISlurmdbV0042PostQosRequest) IncludeDeletedQOS(includeDeletedQOS string) SlurmdbAPISlurmdbV0042PostQosRequest {
	r.includeDeletedQOS = &includeDeletedQOS
	return r
}

// CSV QOS id list
func (r SlurmdbAPISlurmdbV0042PostQosRequest) Id(id string) SlurmdbAPISlurmdbV0042PostQosRequest {
	r.id = &id
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0042PostQosRequest) Format(format string) SlurmdbAPISlurmdbV0042PostQosRequest {
	r.format = &format
	return r
}

// CSV QOS name list
func (r SlurmdbAPISlurmdbV0042PostQosRequest) Name(name string) SlurmdbAPISlurmdbV0042PostQosRequest {
	r.name = &name
	return r
}

// PreemptMode used when jobs in this QOS are preempted
func (r SlurmdbAPISlurmdbV0042PostQosRequest) PreemptMode(preemptMode string) SlurmdbAPISlurmdbV0042PostQosRequest {
	r.preemptMode = &preemptMode
	return r
}

// Description of QOS to add or update
func (r SlurmdbAPISlurmdbV0042PostQosRequest) V0042OpenapiSlurmdbdQosResp(v0042OpenapiSlurmdbdQosResp V0042OpenapiSlurmdbdQosResp) SlurmdbAPISlurmdbV0042PostQosRequest {
	r.v0042OpenapiSlurmdbdQosResp = &v0042OpenapiSlurmdbdQosResp
	return r
}

func (r SlurmdbAPISlurmdbV0042PostQosRequest) Execute() (*V0042OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042PostQosExecute(r)
}

/*
SlurmdbV0042PostQos Add or update QOSs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042PostQosRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042PostQos(ctx context.Context) SlurmdbAPISlurmdbV0042PostQosRequest {
	return SlurmdbAPISlurmdbV0042PostQosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0042PostQosExecute(r SlurmdbAPISlurmdbV0042PostQosRequest) (*V0042OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042PostQos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/qos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "form", "")
	}
	if r.includeDeletedQOS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Include deleted QOS", r.includeDeletedQOS, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.preemptMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "preempt_mode", r.preemptMode, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0042OpenapiSlurmdbdQosResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042PostTresRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0042OpenapiTresResp *V0042OpenapiTresResp
}

// TRES descriptions. Only works in developer mode.
func (r SlurmdbAPISlurmdbV0042PostTresRequest) V0042OpenapiTresResp(v0042OpenapiTresResp V0042OpenapiTresResp) SlurmdbAPISlurmdbV0042PostTresRequest {
	r.v0042OpenapiTresResp = &v0042OpenapiTresResp
	return r
}

func (r SlurmdbAPISlurmdbV0042PostTresRequest) Execute() (*V0042OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042PostTresExecute(r)
}

/*
SlurmdbV0042PostTres Add TRES

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042PostTresRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042PostTres(ctx context.Context) SlurmdbAPISlurmdbV0042PostTresRequest {
	return SlurmdbAPISlurmdbV0042PostTresRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0042PostTresExecute(r SlurmdbAPISlurmdbV0042PostTresRequest) (*V0042OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042PostTres")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/tres/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0042OpenapiTresResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042PostUsersRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	v0042OpenapiUsersResp *V0042OpenapiUsersResp
}

// add or update user
func (r SlurmdbAPISlurmdbV0042PostUsersRequest) V0042OpenapiUsersResp(v0042OpenapiUsersResp V0042OpenapiUsersResp) SlurmdbAPISlurmdbV0042PostUsersRequest {
	r.v0042OpenapiUsersResp = &v0042OpenapiUsersResp
	return r
}

func (r SlurmdbAPISlurmdbV0042PostUsersRequest) Execute() (*V0042OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042PostUsersExecute(r)
}

/*
SlurmdbV0042PostUsers Update users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042PostUsersRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042PostUsers(ctx context.Context) SlurmdbAPISlurmdbV0042PostUsersRequest {
	return SlurmdbAPISlurmdbV0042PostUsersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0042PostUsersExecute(r SlurmdbAPISlurmdbV0042PostUsersRequest) (*V0042OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042PostUsers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/users/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0042OpenapiUsersResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042PostUsersAssociationRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	updateTime *string
	flags *string
	v0042OpenapiUsersAddCondResp *V0042OpenapiUsersAddCondResp
}

// Query partitions updated more recently than this time (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042PostUsersAssociationRequest) UpdateTime(updateTime string) SlurmdbAPISlurmdbV0042PostUsersAssociationRequest {
	r.updateTime = &updateTime
	return r
}

// Query flags
func (r SlurmdbAPISlurmdbV0042PostUsersAssociationRequest) Flags(flags string) SlurmdbAPISlurmdbV0042PostUsersAssociationRequest {
	r.flags = &flags
	return r
}

// Create users with conditional association
func (r SlurmdbAPISlurmdbV0042PostUsersAssociationRequest) V0042OpenapiUsersAddCondResp(v0042OpenapiUsersAddCondResp V0042OpenapiUsersAddCondResp) SlurmdbAPISlurmdbV0042PostUsersAssociationRequest {
	r.v0042OpenapiUsersAddCondResp = &v0042OpenapiUsersAddCondResp
	return r
}

func (r SlurmdbAPISlurmdbV0042PostUsersAssociationRequest) Execute() (*V0042OpenapiUsersAddCondRespStr, *http.Response, error) {
	return r.ApiService.SlurmdbV0042PostUsersAssociationExecute(r)
}

/*
SlurmdbV0042PostUsersAssociation Add users with conditional association

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042PostUsersAssociationRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042PostUsersAssociation(ctx context.Context) SlurmdbAPISlurmdbV0042PostUsersAssociationRequest {
	return SlurmdbAPISlurmdbV0042PostUsersAssociationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiUsersAddCondRespStr
func (a *SlurmdbAPIService) SlurmdbV0042PostUsersAssociationExecute(r SlurmdbAPISlurmdbV0042PostUsersAssociationRequest) (*V0042OpenapiUsersAddCondRespStr, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiUsersAddCondRespStr
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042PostUsersAssociation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/users_association/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "update_time", r.updateTime, "form", "")
	}
	if r.flags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flags", r.flags, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0042OpenapiUsersAddCondResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiUsersAddCondRespStr
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SlurmdbAPISlurmdbV0042PostWckeysRequest struct {
	ctx context.Context
	ApiService SlurmdbAPI
	cluster *string
	format *string
	id *string
	name *string
	onlyDefaults *string
	usageEnd *string
	usageStart *string
	user *string
	withUsage *string
	withDeleted *string
	v0042OpenapiWckeyResp *V0042OpenapiWckeyResp
}

// CSV cluster name list
func (r SlurmdbAPISlurmdbV0042PostWckeysRequest) Cluster(cluster string) SlurmdbAPISlurmdbV0042PostWckeysRequest {
	r.cluster = &cluster
	return r
}

// Ignored; process JSON manually to control output format
func (r SlurmdbAPISlurmdbV0042PostWckeysRequest) Format(format string) SlurmdbAPISlurmdbV0042PostWckeysRequest {
	r.format = &format
	return r
}

// CSV ID list
func (r SlurmdbAPISlurmdbV0042PostWckeysRequest) Id(id string) SlurmdbAPISlurmdbV0042PostWckeysRequest {
	r.id = &id
	return r
}

// CSV name list
func (r SlurmdbAPISlurmdbV0042PostWckeysRequest) Name(name string) SlurmdbAPISlurmdbV0042PostWckeysRequest {
	r.name = &name
	return r
}

// Only query defaults
func (r SlurmdbAPISlurmdbV0042PostWckeysRequest) OnlyDefaults(onlyDefaults string) SlurmdbAPISlurmdbV0042PostWckeysRequest {
	r.onlyDefaults = &onlyDefaults
	return r
}

// Usage end (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042PostWckeysRequest) UsageEnd(usageEnd string) SlurmdbAPISlurmdbV0042PostWckeysRequest {
	r.usageEnd = &usageEnd
	return r
}

// Usage start (UNIX timestamp)
func (r SlurmdbAPISlurmdbV0042PostWckeysRequest) UsageStart(usageStart string) SlurmdbAPISlurmdbV0042PostWckeysRequest {
	r.usageStart = &usageStart
	return r
}

// CSV user list
func (r SlurmdbAPISlurmdbV0042PostWckeysRequest) User(user string) SlurmdbAPISlurmdbV0042PostWckeysRequest {
	r.user = &user
	return r
}

// Include usage
func (r SlurmdbAPISlurmdbV0042PostWckeysRequest) WithUsage(withUsage string) SlurmdbAPISlurmdbV0042PostWckeysRequest {
	r.withUsage = &withUsage
	return r
}

// Include deleted WCKeys
func (r SlurmdbAPISlurmdbV0042PostWckeysRequest) WithDeleted(withDeleted string) SlurmdbAPISlurmdbV0042PostWckeysRequest {
	r.withDeleted = &withDeleted
	return r
}

// wckeys description
func (r SlurmdbAPISlurmdbV0042PostWckeysRequest) V0042OpenapiWckeyResp(v0042OpenapiWckeyResp V0042OpenapiWckeyResp) SlurmdbAPISlurmdbV0042PostWckeysRequest {
	r.v0042OpenapiWckeyResp = &v0042OpenapiWckeyResp
	return r
}

func (r SlurmdbAPISlurmdbV0042PostWckeysRequest) Execute() (*V0042OpenapiResp, *http.Response, error) {
	return r.ApiService.SlurmdbV0042PostWckeysExecute(r)
}

/*
SlurmdbV0042PostWckeys Add or update wckeys

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SlurmdbAPISlurmdbV0042PostWckeysRequest
*/
func (a *SlurmdbAPIService) SlurmdbV0042PostWckeys(ctx context.Context) SlurmdbAPISlurmdbV0042PostWckeysRequest {
	return SlurmdbAPISlurmdbV0042PostWckeysRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return V0042OpenapiResp
func (a *SlurmdbAPIService) SlurmdbV0042PostWckeysExecute(r SlurmdbAPISlurmdbV0042PostWckeysRequest) (*V0042OpenapiResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *V0042OpenapiResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SlurmdbAPIService.SlurmdbV0042PostWckeys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/slurmdb/v0.0.42/wckeys/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster", r.cluster, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.onlyDefaults != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_defaults", r.onlyDefaults, "form", "")
	}
	if r.usageEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_end", r.usageEnd, "form", "")
	}
	if r.usageStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage_start", r.usageStart, "form", "")
	}
	if r.user != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "user", r.user, "form", "")
	}
	if r.withUsage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_usage", r.withUsage, "form", "")
	}
	if r.withDeleted != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_deleted", r.withDeleted, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v0042OpenapiWckeyResp
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["user"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-NAME"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-SLURM-USER-TOKEN"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v V0042OpenapiResp
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
